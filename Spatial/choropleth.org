#+PROPERTY:  header-args :session *R* :tangle ../docs/R/choropleth.R :eval no-export
#+OPTIONS: ^:nil

#+begin_src R :exports none :tangle no
setwd("~/github/bookvis/")
#+end_src


#+begin_src R :exports none  
##################################################################
## Initial configuration
##################################################################
## Clone or download the repository and set the working directory
## with setwd to the folder where the repository is located.
 
library("lattice")
library("ggplot2")
## latticeExtra must be loaded after ggplot2 to prevent masking of its
## `layer` function.
library("latticeExtra")

source("configLattice.R")
##################################################################
#+end_src


* Introduction

This chapter details how to create choropleth maps depicting the
results of the 2016 Spanish general elections. The section
ref:sec:dataChoropleth describes how to define a shapefile[fn:8]
combining the data from a =data.frame= and the spatial information of
the administrative boundaries.

\nomenclature{shapefile}{A geospatial vector data format developed by Esri that can store vector features (points, lines, and polygons), and with attributes that describe these features (name of the location, temperature, etc.).

As exposed in Chapter ref:cha:bubble, two alternatives are available: 

1. The =sp= package and the =spplot= function (based on =lattice= graphics).
2. The =sf= package and the =geom_sf= function (based on =ggplot2= graphics).

In both cases, the data is imported with the =sf= package and its
function =st_read=, returning an object of class =sf=.

** Read Data

#+begin_src R :exports none  
##################################################################
## Read data
##################################################################
#+end_src

The shapefile is read with the =st_read= to produce a =sf=
object. Because the coordinate reference system[fn:4] is not stored in
the files, it must be set with the =crs= argument.

#+INDEX: Data!INE
#+INDEX: Data!Spanish General Elections
#+INDEX: Packages!sf@\texttt{sf}

#+begin_src R 
library("sf")

sfMapVotes <- st_read("data/Spatial/sfMapVotes.shp")
#+end_src

This =object= contains two main variables: =whichMax=, the name of the
predominant political option, and =pcMax=, the percentage of votes
obtained by this political option.

#+begin_src R :results output :exports results :tangle no
sfMapVotes$whichMax <- factor(sfMapVotes$whichMax)
sfMapVotes$PROV <- factor(sfMapVotes$PROV)

summary(sfMapVotes)
#+end_src

#+ATTR_LATEX: :environment results
#+RESULTS:
#+begin_example
    SP_ID             PROVMUN            whichMax              Max          
 Length:8110        Length:8110        Length:8110        Min.   :     2.0  
 Class :character   Class :character   Class :character   1st Qu.:    54.0  
 Mode  :character   Mode  :character   Mode  :character   Median :   162.0  
                                                          Mean   :  1395.9  
                                                          3rd Qu.:   636.5  
                                                          Max.   :696804.0  
     pcMax                geometry   
 Min.   :21.33   MULTIPOLYGON :8110  
 1st Qu.:31.68   epsg:25830   :   0  
 Median :35.64   +proj=utm ...:   0  
 Mean   :37.58                       
 3rd Qu.:41.27                       
 Max.   :94.74
#+end_example


** Province Boundaries
#+begin_src R :exports none  
##################################################################
## Province Boundaries
##################################################################
#+end_src

As a visual aid, the subsequent maps will be produced with the
province boundaries superposed. These boundaries are encoded in the
=spain_provinces= shapefile. 

#+begin_src R
sfProvs <- st_read("data/Spatial/spain_provinces.shp",
                   crs = 25830)
#+end_src

#+RESULTS:

* Quantitative Variable
label:sec:quantitative_choropleth

#+begin_src R :exports none  
##################################################################
## Quantitative variable
##################################################################
#+end_src

First, let's display =pcMax=, a quantitative variable increasing from
low to high. This type of variables are well suited to sequential
palettes, that communicate the progression from low to high with light
colors associated to low values, and dark colors linked to high
values. The well-known service ColorBrewer[fn:1] provides several
choices, available in =R= via the =RColorBrewer= package
cite:Neuwirth2014.

#+INDEX: Packages!RColorBrewer@\texttt{RColorBrewer}
#+INDEX: Subjects!Sequential palette

#+begin_src R
library("RColorBrewer")

## Number of intervals (colors)
N <- 6
## Sequential palette
quantPal <- brewer.pal(n = N, "Oranges")
#+end_src

The most common approach with choropleth maps, the classed choropleth,
is to divide the data into classes. Although this method produces a
filtered view of the data, it reduces the random noise in the
information, and makes it easy to compare regions. A different
alternative is the unclassed choropleth, where each unique data value
gets a unique color. This approach is recommended to get a unfiltered
view of the data and highlight overall geographic patterns of the
variable.

Figure ref:fig:pcMaxUC is an unclassed choropleth depicting the
=pcMax= variable. It uses a palette created by interpolation with the
=colorRampPalette= function.
 
#+begin_src R :results output graphics file :exports both :file figs/Spatial/pcMaxUC.pdf
ggplot(sfMapVotes) +
  ## Display the pcMax variable...
  geom_sf(aes(fill = pcMax),
          ## without drawing municipality boundaries
          color = "transparent") +
  scale_fill_gradientn(colours = quantPal) +
  ## And overlay provinces boundaries
  geom_sf(data = sfProvs,
          fill = 'transparent',
          ## but do not include them in the legend
          show.legend = FALSE) +
  theme_bw()
#+end_src
#+CAPTION: Quantitative choropleth map displaying the percentage of votes obtained by the predominant political option in each municipality in the 2016 Spanish general elections using a continuous color ramp (unclassed choropleth). label:fig:pcMaxUC
#+RESULTS:
[[file:figs/Spatial/pcMaxUC.pdf]]

The =spplot= version requires a conversion from =sf= to a
=SpatialPolygonsDataFrame= class with =as=.
#+begin_src R
library(sp)

spMapVotes <- as(sfMapVotes, "Spatial")
spProvs <- as(sfProvs, "Spatial")
#+end_src

The =spMapVotes= object is displayed with =spplot= and the province
boundaries are superimposed with the argument =sp.layout= (see section
ref:sec:bubbles_osm for details).

#+begin_src R
## Number of cuts
ucN <- 1000
## Palette created with interpolation
ucQuantPal <- colorRampPalette(quantPal)(ucN)
#+end_src

#+begin_src R
## Province boundaries
provinceLines <- list("sp.polygons",
                      spProvs,
                      lwd = 0.1,
                      # draw the lines after the data
                      first = FALSE)
#+end_src

#+begin_src R :eval no-export
## Main plot
spplot(spMapVotes["pcMax"],
       col.regions = ucQuantPal,
       cuts = ucN,
       ## Do not draw municipality boundaries
       col = "transparent",
       ## Overlay province boundaries
       sp.layout = provinceLines)    
#+end_src


** Data Classification
#+begin_src R :exports none  
##################################################################
## Data classification
##################################################################
#+end_src

It is evident in Figure ref:fig:pcMaxUC that the =pcMax= variable is
concentrated in the 0.2-0.4 range. Figure ref:fig:densityChoropleth
displays the density estimation of this variable grouping by the
political option. This result suggests to use data classification.

#+INDEX: Subjects!Class Intervals

#+begin_src R :results output graphics file :exports both :file figs/Spatial/densityChoropleth.pdf
ggplot(as.data.frame(spMapVotes),
       aes(pcMax,
           fill = whichMax,
           colour = whichMax)) +
    geom_density(alpha = 0.1) +
    theme_bw()
#+end_src

#+CAPTION: Density estimation of the predominant political option in each municipality in the 2016 Spanish general elections grouping by the political option. label:fig:densityChoropleth
#+RESULTS:
[[file:figs/Spatial/densityChoropleth.pdf]]

The number of data classes is the result of a compromise between
information amount and map legibility. A general recommendation is to
use three to seven classes, depending on the data. 

On the other hand, there is a wide catalog of classification methods,
and the =classInt= package implements most of them (previously used in
Section ref:sec:classification_bubble). Figures
ref:fig:quantile_intervals and ref:fig:fisher_intervals depict the
empirical cumulative distribution function of =pcMax= with the
intervals computed with the quantile method and the natural breaks
method, a clustering method that seeks to reduce the variance within
classes and maximize the variance between classes. As it can be
inferred from the density estimation (Figure
ref:fig:densityChoropleth), the natural breaks method is preferred in
this example, because with the quantile method very different values
will be assigned to the same class.

#+INDEX: Packages!classInt@\texttt{classInt}

#+begin_src R
library("classInt")

## Compute intervals with the same number of elements
intQuant <- classIntervals(sfMapVotes$pcMax,
                           n = N, style = "quantile")
## Compute intervals with the natural breaks algorithm
intFisher <- classIntervals(sfMapVotes$pcMax,
                            n = N, style = "fisher")
#+end_src

#+RESULTS:

#+begin_src R :results output graphics file :exports both :file figs/Spatial/quantile_intervals.pdf
plot(intQuant, pal = quantPal, main = "")
#+end_src
#+CAPTION: Quantile method for setting class intervals label:fig:quantile_intervals
#+RESULTS:
#+ATTR_LATEX: :height 0.4\textheight
[[file:figs/Spatial/quantile_intervals.pdf]]

#+begin_src R :results output graphics file :exports both :file figs/Spatial/fisher_intervals.pdf
plot(intFisher, pal = quantPal, main = "")
#+end_src
#+CAPTION: Natural breaks method for setting class intervals label:fig:fisher_intervals
#+RESULTS:
#+ATTR_LATEX: :height 0.4\textheight
[[file:figs/Spatial/fisher_intervals.pdf]]


Figure ref:fig:pcMax is a classed choropleth with the natural breaks
classification. It is produced with =spplot= displaying a categorical
variable created with the function =cut= and the breaks computed with
=classIntervals=.

#+begin_src R :results output graphics file :exports both :file figs/Spatial/pcMax.pdf
## spplot solution

## Add a new categorical variable with cut, using the computed breaks
spMapVotes$pcMaxInt <- cut(spMapVotes$pcMax,
                           breaks = intFisher$brks,
                           include.lowest = TRUE)

spplot(spMapVotes["pcMaxInt"],
       col = "transparent",
       col.regions = quantPal,
       sp.layout = provinceLines)
#+end_src

#+CAPTION: Quantitative choropleth map displaying the percentage of votes obtained by the predominant political option in each municipality in the 2016 Spanish general elections using a classification (classed choropleth). label:fig:pcMax
#+RESULTS:
[[file:figs/Spatial/pcMax.pdf]]

The next code is the version of this figure with =ggplot2=:
#+begin_src R
## sf and geom_sf
sfMapVotes$pcMaxInt <- cut(sfMapVotes$pcMax,
                           breaks = intFisher$brks,
                           include.lowest = TRUE)

ggplot(sfMapVotes) +
  geom_sf(aes(fill = pcMaxInt),
          color = "transparent") +
  scale_fill_brewer(palette = "Oranges") +
  geom_sf(data = sfProvs,
          fill = "transparent",
          show.legend = FALSE) +
  theme_bw()
#+end_src


* Qualitative Variable
#+begin_src R :exports none  
##################################################################
## Qualitative variable
##################################################################
#+end_src

On the other hand, =whichMax= is a categorical value with four levels:
the main parties (=PP=, =PSOE=, =UP=, =Cs=), the abstention results
(=ABS=), and the rest of the parties (=OTH=). 

#+begin_src R :results output :exports results :tangle no
spMapVotes$whichMax <- factor(spMapVotes$whichMax)

summary(spMapVotes$whichMax)
#+end_src

#+RESULTS:
:  ABS  C.s  OTH   PP PSOE   UP 
: 2812    3  170 4212  776  137

Figure ref:fig:whichMax encodes these levels with a qualitative palette from ColorBrewer.

#+INDEX: Packages!RColorBrewer@\texttt{RColorBrewer}
#+INDEX: Subjects!Qualitative palette

#+begin_src R 
classes <- levels(spMapVotes$whichMax)
nClasses <- length(classes)

qualPal <- brewer.pal(nClasses, "Dark2")
#+end_src

#+begin_src R :results output graphics file :exports both :file figs/Spatial/whichMax.pdf
## spplot solution
spplot(spMapVotes["whichMax"],
       col.regions = qualPal,
       col = 'transparent',
       sp.layout = provinceLines)
#+end_src

#+CAPTION: Categorical choropleth map displaying the name of the predominant political option in each municipality in the 2016 Spanish general elections. label:fig:whichMax
#+RESULTS:
[[file:figs/Spatial/whichMax.pdf]]

The next code is the version of this figure with =ggplot2=:
#+begin_src R
## geom_sf solution
ggplot(sfMapVotes) +
  geom_sf(aes(fill = whichMax),
          color = "transparent") +
  scale_fill_brewer(palette = "Dark2") +
  geom_sf(data = sfProvs,
          fill = "transparent",
          show.legend = FALSE) +
  theme_bw()
#+end_src

* Small Multiples with Choropleth Maps
#+begin_src R :exports none  
##################################################################
## Small multiples
##################################################################
#+end_src

Both the quantitative and qualitative variables can be combined using
the small multiples technique (Sections ref:SEC:sameScale and
ref:SEC:groupVariable) cite:Tufte1990: multiple maps displayed all at
once to compare the differences between them. The next code produce a
matrix of maps, with a map for each political option defined by the
categorical variable =whichMax=. The =spplot= function
provides a =formula= argument to divide the data into panels. However,
its usage is not well documented and cannot be recommended. Instead,
the =ggplot= approach is easy to use thanks to the =facet_wrap=
function. The result is displayed in Figure ref:fig:pcMax_panels.

#+INDEX: Subjects!Small multiples

#+begin_src R :results output graphics file :exports both :file figs/Spatial/pcMax_panels.pdf
ggplot(sfMapVotes) +
  geom_sf(aes(fill = pcMaxInt),
          color = "transparent") +
  ## Define the faceting using two rows
  facet_wrap(~whichMax, nrow = 2) +
  scale_fill_brewer(palette = "Oranges") +
  geom_sf(data = sfProvs,
          fill = "transparent",
          size = 0.1,
          show.legend = FALSE) +
  theme_bw()
#+end_src


#+CAPTION: Small multiple choropleth maps of the Spanish general elections results. Each map shows the results of a political option in each municipality. label:fig:pcMax_panels
#+RESULTS:
[[file:figs/Spatial/pcMax_panels.pdf]]

* Bivariate Map
label:sec:multiChoropleth
#+begin_src R :exports none
##################################################################
## Bivariate map
##################################################################
#+end_src

Following the inspiring example of the infographic titled "Immigration
Explorer" published by the /New York Times/[fn:2], we will combine the
choropleth maps of both variables to produce a bivariate map[fn:7]:
the hue of each polygon will be determined by the name of the
predominant option (=whichMax=) but the transparency will vary
according to the percentage of votes (=pcMax=).

In previous sections, we use six intervals to represent the
quantitative variable =pcMax=. However, in this case we must reduce
this number: in order to improve the map legibility, each ramp has
only four steps.

Moreover, the qualitative variable =whichMax= will also be reduced,
also from six to 4, grouping the political parties into political
options: 

#+begin_src R
## PP and Cs -> Right
## PSOE and UP -> Left
levels(sfMapVotes$whichMax) <-
  c("ABS", "Right", "OTH", "Right", "Left", "Left")
#+end_src

Next code creates a bidimensional palette joining four different
sequential palettes (one for each level of =whichMax=) with four
steps. Thus, the bivariate legend will be composed of sixteen colors.

#+INDEX: Subjects!Sequential palette
#+INDEX: Subjects!Qualitative palette

#+begin_src R
## Number of steps.
Nint <- 4
## ABS - Greys, Right - Blues, OTH - Greens, Left - Reds
multiPal <- lapply(c("Greys", "Blues", "Greens", "Reds"),
                   function(pal) brewer.pal(Nint, pal))
multiPal <- do.call(rbind, multiPal)
#+end_src


The =biscale= package contains functions for bivariate mapping with
=ggplot2=. First, the function =bi_class= returns a =sf= object with a
new column, =bi_class=, defining the class of each element according
to the value of =whicMax= and =pcMax=.
#+begin_src R
library(biscale)


sfClass <- bi_class(sfMapVotes,
               x = whichMax,
               y = pcMax,
               style = "fisher",
               dim = 4)
#+end_src

The next step is to create the legend with =bi_legend=. This function
requires a bivariate palette as a named vector. The next code
transforms the previous =multiPal= matrix into a vector, adds the
required names, and produces the legend.
#+begin_src R
bipal <- c(multiPal)

nms <- outer(1:4, 1:4, paste, sep = "-")
names(bipal) <- c(nms)

bilegend <- bi_legend(pal = bipal,
                      dim = 4,
                      xlab = "ABS-Right-OTH-Left",
                      ylab = "% of votes ",
                      size = 8)
#+end_src

Finally, the bivariate map is created with =geom_sf= combined with
=bi_scale_fill=, both of them fed with the last results, =sfClass= and
=bipal=. However, the legend cannot be added directly.
#+begin_src R
bimap <- ggplot() +
  geom_sf(data = sfClass,
          aes(fill = bi_class),
          color = "white",
          size = 0.1,
          show.legend = FALSE) +
  bi_scale_fill(pal = bipal, dim = 4) +
  bi_theme()
#+end_src

The complete map is produced with the package =cowplot= and its
functions =ggdraw= and =draw_plot=. This function displays the map
(=bimap=) and the legend (=bilegend=) in their respective
locations. Figure ref:fig:mapLegends displays the result.

#+begin_src R :results output graphics file :exports both :file figs/Spatial/mapLegends.pdf
library(cowplot)

ggdraw() +
  draw_plot(bimap, 0, 0, 1, 1) +
  draw_plot(bilegend, 0.05, 0.1,
            width = 0.2, height = 0.2)
#+end_src

#+CAPTION: Bidimensional choropleth map of the Spanish general elections results. The map shows the result of the most voted option in each municipality. label:fig:mapLegends
#+RESULTS:
[[file:figs/Spatial/mapLegends.pdf]]

There is no package for the =spplot= approach, so the solution must be
built step by step. First, the classes are defined with
=classIntervals= and =cut=:
#+INDEX: Subjects!Class Intervals
#+INDEX: Packages!classInt@\texttt{classInt}

#+begin_src R
## Define the intervals
intFisher <- classIntervals(spMapVotes$pcMax,
                            n = Nint, style = "fisher")
## ... and create a categorical variable with them
spMapVotes$pcMaxInt <- cut(spMapVotes$pcMax,
                           breaks = intFisher$brks)
#+end_src

Then, we can produce a list of maps extracting the polygons according
to each class of the qualitative variable, and filling with the
appropriate color from the =multiPal= palette. The resulting list of
=trellis= objects can be combined with =Reduce= and the =+.trellis=
function of the =latticeExtra= and produce a =trellis= object.

#+begin_src R :eval no-export
levels(spMapVotes$whichMax) <-
  c("ABS", "Right", "OTH", "Right", "Left", "Left")

classes <- levels(spMapVotes$whichMax)
nClasses <- length(classes)

pList <- lapply(1:nClasses, function(i)
{
  ## Only those polygons corresponding to a level are selected
  mapClass <- subset(spMapVotes,
                     whichMax == classes[i])
  ## Palette
  pal <- multiPal[i, ]
  ## Produce the graphic
  pClass <- spplot(mapClass, "pcMaxInt",
                   col.regions = pal,
                   col = "transparent",
                   colorkey = FALSE)
})
names(pList) <- classes
p <- Reduce("+", pList)
#+end_src

#+begin_src R :exports none
op <- options(digits = 4)
tabFisher <- print(intFisher)
intervals <- names(tabFisher)
options(op)
#+end_src

The bidimensional legend of this graphic is produced with
=grid.raster=, a function of the =grid= package, able to display a
color matrix (line [[(gridRaster)]]). The axis of the color matrix are
created with =grid.text= (lines [[(gridTextX)]] and [[(gridTextY)]]).

#+INDEX: Packages!grid@\texttt{grid}

#+begin_src R -n -r
library("grid")

legend <- layer(
{
    ## Position of the legend
    x0 <- 1000000
    y0 <- 4200000
    ## Width of the legend 
    w <- 120000
    ## Height of the legend
    h <- 100000
    ## Colors
    grid.raster(multiPal, interpolate = FALSE,                (ref:gridRaster)
                x = unit(x0, "native"),
                y = unit(y0, "native"),
                width = unit(w, "native"),
                height = unit(h, "native"))
    ## x-axis (quantitative variable)
    Ni <- length(intervals)                                   (ref:gridTextX)
    grid.text(intervals,                      
              y = unit(y0 - 1.25 * h/2, "native"),
              x = unit(seq(x0 - w * (Ni -1)/(2*Ni),
                           x0 + w * (Ni -1)/(2*Ni),
                           length = Ni),
                       "native"),
              just = "top",
              rot = 45, 
              gp = gpar(fontsize = 6))
    ## y-axis (qualitative variable)
    grid.text(classes,                                        (ref:gridTextY)                        
              y = unit(seq(y0 + h * (nClasses -1)/(2*nClasses),
                           y0 - h * (nClasses -1)/(2*nClasses),
                           length = nClasses),
                       "native"),
              x = unit(x0 + w/2, "native"),
              just = "left",
              gp = gpar(fontsize = 6))
})

#+end_src

Last step, the bivariate map and the legend are displayed together:
#+begin_src R :eval no-export
## Main plot
p + legend
#+end_src


* Interactive Graphics
label:sec:interactive_choropleth
#+begin_src R :exports none  
##################################################################
## Interactive Graphics
##################################################################
#+end_src

#+INDEX: Subjects!Interactive visualization

The package =mapview= was used in section ref:sec:mapview_bubble to
produce interactive proportional symbol maps. In this section this package creates interactive choropleth maps. 

#+INDEX: Packages!mapview@\texttt{mapview}

#+begin_src R
library("mapview")
#+end_src

This package is able to work both with =sp= and with =sf=. In this section we use the =sf= package to read the data[fn:5]. 

#+begin_src R
sfMapVotes0 <- st_read("data/Spatial/sfMapVotes0.shp",
                       crs = 25830)
#+end_src

Figures ref:fig:mapview_pcMax and ref:fig:mapview_whichMax show the snapshots of the interactive choropleth maps of =pcMax= and =whichMax=, respectively. These maps are produced with the next code.

#+begin_src R
## Quantitative variable, pcMax
mapView(sfMapVotes0,
        zcol = "pcMax", ## Choose the variable to display
        legend = TRUE,
        col.regions = quantPal)
#+end_src

#+CAPTION: Snapshot of the interactive quantitative choropleth map produced with =mapview=. label:fig:mapview_pcMax
file:figs/Spatial/mapview_pcMax.png

#+begin_src R
## Qualitative variable, whichMax
mapView(sfMapVotes0,
        zcol = "whichMax",
        legend = TRUE,
        col.regions = qualPal)
#+end_src

#+CAPTION: Snapshot of the interactive qualitative choropleth map produced with =mapview=. label:fig:mapview_whichMax
file:figs/Spatial/mapview_whichMax.png


* Cartogram

#+begin_src R
library("sf")
library("ggplot2")
library("cartogram")
#+end_src

#+begin_src R
sfPopulation <- st_read("data/Spatial/sfPopulation.shp")

ggplot(sfPopulation) +
  geom_sf(aes(fill = population)) + 
  scale_fill_gradientn(colours = quantPal) +
  theme_bw()
#+end_src

#+begin_src R
cartPopCont <- cartogram_cont(sfPopulation, weight = "population")

ggplot(cartPopCont) +
  geom_sf(aes(fill = population)) + 
  scale_fill_gradientn(colours = quantPal) +
  theme_bw()
#+end_src

#+begin_src R
cartPopNCont <- cartogram_ncont(sfPopulation, weight = "population")

ggplot(cartPopNCont) +
  geom_sf(aes(fill = population)) + 
  scale_fill_gradientn(colours = quantPal) +
  theme_bw()
#+end_src

#+begin_src R
cartPopDorl <- cartogram_dorling(sfPopulation, weight = "population")

ggplot(cartPopDorl) +
  geom_sf(aes(fill = population)) + 
  scale_fill_gradientn(colours = quantPal) +
  theme_bw()
#+end_src


* Footnotes
[fn:2] Available at https://archive.nytimes.com/www.nytimes.com/interactive/2009/03/10/us/20090310-immigration-explorer.html. 

[fn:8] The shapefile format is a geospatial vector data format developed by Esri that can store vector features (points, lines, and polygons), and with attributes that describe these features (name of the location, temperature, etc.).

[fn:7] Although bivariate maps are generally used to display the relationship between two variables, they can also be used to display one variable and its uncertainty. More information about visualizing uncertainty with maps can be found in cite:Lucchesi.Wikle2017 and the package =VizU= (https://github.com/pkuhnert/VizU).

[fn:5] In previous sections the spatial object included a modification to the original shapefile in order to display the Canarian islands in the right bottom corner of the maps. This modification is not needed with =mapview=, so =st_read= imports the shapefile =spMapVotes0= (Section ref:sec:dataChoropleth).

[fn:4] The EPSG projection of the data is 25830. More information in http://spatialreference.org/ref/epsg/etrs89-utm-zone-30n/.

[fn:1] http://colorbrewer2.org




