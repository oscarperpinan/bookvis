#+PROPERTY: header-args :session *R* :tangle ../docs/R/osm.R :eval no-export
#+OPTIONS: ^:nil

#+begin_src R :exports none :tangle no
setwd('~/github/bookvis/')
#+end_src

#+begin_src R :exports none  
##################################################################
## Initial configuration
##################################################################
## Clone or download the repository and set the working directory
## with setwd to the folder where the repository is located.
library("lattice")
library("ggplot2")
## latticeExtra must be loaded after ggplot2 to prevent masking of its
## `layer` function.
library("latticeExtra")

source("configLattice.R")

library("RColorBrewer")
library("colorspace")

library("raster")
library("terra")

library("rasterVis")
library("tidyterra")
#+end_src

* Reference maps
label:sec:reference

Although I was born in Madrid, Galicia (north of Spain) is a very
special region for me. More precisely, the Cedeira and Valdovi√±o
regions offer a wonderful combination of wild sea, secluded beaches,
and forests. I will show you a map of these marvelous places.

** Retrieving Data from OpenStreetMap
#+begin_src R :exports none
##################################################################
## Retrieving data from OpenStreetMap
##################################################################
#+end_src

The first step is to acquire information from the OpenStreetMap (OSM)
project. There are several packages to extract data from this service
but, while most of them only provide already rendered raster images,
the =osmdata= package enables the use of the raw data with
classes of the packages =sp= and =sf=.

The =osmdata= package obtains data from the overpass API[fn:2], a
read-only API that serves up custom selected parts of the OSM map
data. The first step is specifying the bounding box with the function
=opq=:

#+INDEX: Data!OpenStreetMap
#+INDEX: Packages!osmdata@\texttt{osmdata}

#+begin_src R
library("osmdata")
library("sf")
library("sp")


## Bounding box
xmin <- -8.1
ymin <- 43.62
xmax <- -8
ymax <- 43.7 
cedeiraBB <- c(xmin = xmin, ymin = ymin,
               xmax = xmax, ymax = ymax) 

## Overpass query
cedeiraOPQ <- opq(cedeiraBB)
#+end_src

Next, the query is completed adding the required features with
=add_osm_feature=. The three main arguments of this function are the
overpass query defined with =opq=, the feature =key=, and the =value=
of this feature. Finally, the information contained in the query can
be obtained as a =Spatial*= object with =osmdata_sp=, or as a =sf=
object with =osmdata_sf=. The result is a list with three components,
=osm_points=, =osm_lines=, and =osm_polygons=, containing the
respective spatial object. 

For example, the next code obtains the residential streets in the
region as a list of =Spatial*= objects.

#+begin_src R :results output :exports both
streetsOSM <- add_osm_feature(cedeiraOPQ,
                              key = "highway",
                              value = "residential")

streetsSP <- osmdata_sp(streetsOSM)

print(streetsSP)
#+end_src

#+RESULTS[d459f4bbe11478d2e301df7172c4154d2b6cf2cf]:
: Object of class 'osmdata' with:
:                  $bbox : 43.62,-8.1,43.7,-8
:         $overpass_call : The call submitted to the overpass API
:                  $meta : metadata including timestamp and version numbers
:            $osm_points : 'sp' SpatialPointsDataFrame with 1470 points
:             $osm_lines : 'sp' SpatialLinesDataFrame with 226 lines
:          $osm_polygons : 'sp' SpatialPolygonsDataFrame with 7 polygons
:        $osm_multilines : 'sp' SpatialNADataFrame with 0 multilines
:     $osm_multipolygons : 'sp' SpatialPolygonsDataFrame with 0 multipolygons


Because this procedure is to be repeated several times, I define a
wrapper function that provides a =SpatialLinesDataFrame= object or a
=SpatialPointsDataFrame= object depending on the value of its argument
=type=:
#+begin_src R
spFromOSM <- function(source, key, value, type = 'lines')
{
    osm <- add_osm_feature(source, key, value)
    spdata <- osmdata_sp(osm)
    switch(type,
           lines = spdata$osm_lines,
           points = spdata$osm_points)
}
#+end_src  
and a function that provides a =sf= object:
#+begin_src R
sfFromOSM <- function(bb, key, value, type = 'lines')
{
  source <- opq(bb)
  osm <- add_osm_feature(source, key, value)
  sfdata <- osmdata_sf(osm)
  switch(type,
         lines = st_crop(sfdata$osm_lines, bb),
         points = sfdata$osm_points)
  
}
#+end_src  

The next code uses these functions to obtain the different types of
roads and streets in the region as =SpatialLinesDataFrame= objects:
#+begin_src R 
streetsSP <- spFromOSM(cedeiraOPQ,
                       key = "highway", value = "residential")
primarySP <- spFromOSM(cedeiraOPQ,
                       key = "highway", value = "primary")
secondarySP <- spFromOSM(cedeiraOPQ,
                         key = "highway", value = "secondary")
tertiarySP <- spFromOSM(cedeiraOPQ,
                        key = "highway", value = "tertiary")
unclassifiedSP <- spFromOSM(cedeiraOPQ,
                            key = "highway", value = "unclassified")
footwaySP <- spFromOSM(cedeiraOPQ,
                       key = "highway", value = "footway")
stepsSP <- spFromOSM(cedeiraOPQ,
                     key = "highway", value = "steps")
#+end_src  
and =sf= objects:
#+begin_src R 
streetsSF <- sfFromOSM(cedeiraBB,
                       key = "highway", value = "residential")
primarySF <- sfFromOSM(cedeiraBB,
                       key = "highway", value = "primary")
secondarySF <- sfFromOSM(cedeiraBB,
                         key = "highway", value = "secondary")
tertiarySF <- sfFromOSM(cedeiraBB,
                        key = "highway", value = "tertiary")
unclassifiedSF <- sfFromOSM(cedeiraBB,
                            key = "highway", value = "unclassified")
footwaySF <- sfFromOSM(cedeiraBB,
                       key = "highway", value = "footway")
stepsSF <- sfFromOSM(cedeiraBB,
                     key = "highway", value = "steps")
#+end_src  

A similar procedure can be applied to construct a =SpatialPointsDataFrame=
object with the collection of places with name:
#+begin_src R 
citySP <- spFromOSM(cedeiraOPQ, key = "place",
                    value = "town", type = "points")

placesHsp <- spFromOSM(cedeiraOPQ, key = "place",
                       value = "hamlet", type = "points")
placesHsp <- subset(placesHsp, as.numeric(population) > 30)
#+end_src  
The =sfFromOSM= function retrieves the same information as =sf= objects:
#+begin_src R 
citySF <- sfFromOSM(cedeiraBB, key = "place",
                    value = "town", type = "points")

placesHsf <- sfFromOSM(cedeiraBB, key = "place",
                       value = "hamlet", type = "points")
placesHsf <- subset(placesHsf, as.numeric(population) > 30)
#+end_src  

** Hill Shading
label:sec:hill-shading-osm
#+begin_src R :exports none
##################################################################
## Hill Shading
##################################################################
#+end_src

#+INDEX: Subjects!Hill shading

The second step is to produce layers to display the topography. A
suitable method is shaded relief or hill shading, previously exposed
in section ref:sec:hill-shading-raster.

The hill shade layer is computed from the slope and aspect layers
derived from a Digital Elevation Model. The DEM of Galicia is
available at the Geonetwork service of the Xunta de Galicia[fn:1]. I
have extracted the data corresponding to the region of interest using
=crop=, and the corresponding files are available at the =data= folder
of the book repository.

#+INDEX: Packages!raster@\texttt{raster}
#+INDEX: Packages!raster@\texttt{terra}
#+INDEX: Data!Geonetwork

#+begin_src R
library("raster")
projCedeira <- projection(citySP)

demCedeira <- raster('data/Spatial/demCedeira')
projection(demCedeira) <- projCedeira

## Crop the DEM using the bounding box of the OSM data
OSMextent <- extent(extendrange(c(xmin, xmax)),
                    extendrange(c(ymin, ymax)))
demCedeira <- crop(demCedeira, OSMextent)

## Discard values below sea level
demCedeira[demCedeira <= 0] <- NA
#+end_src

#+begin_src R :results output :exports none :tangle no
print(demCedeira)
#+end_src
#+RESULTS[cbcca86914b4778f755b427e1be3ef8f0a6c3628]:
: class      : RasterLayer 
: dimensions : 380, 475, 180500  (nrow, ncol, ncell)
: resolution : 0.00023147, 0.00023147  (x, y)
: extent     : -8.105, -7.995052, 43.61599, 43.70395  (xmin, xmax, ymin, ymax)
: crs        : +proj=longlat +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +no_defs 
: source     : memory
: names      : layer 
: values     : 1, 438  (min, max)

The =slope= and =aspect= layers are computed with the =terrain=
function, and the hill shade layer is derived with these layers for a
fixed sun position. 

#+begin_src R 
slope <- terrain(demCedeira, 'slope')
aspect <- terrain(demCedeira, 'aspect')
hsCedeira <- hillShade(slope = slope, aspect = aspect,
                       angle = 20, direction = 30)
#+end_src

As it has been explained in sections [[ref:sec:quantitative_raster]] and ref:sec:hill-shading-raster, this same procedure can be implemented with the =terra= package. It will be not be repeated here. For simplicity, we will use the conversion function:
#+begin_src R
library("terra")

demCedeiraT <- rast(demCedeira)
hsCedeiraT <- rast(hsCedeira)
#+end_src

** Overlaying Layers of Information
#+begin_src R :exports none
##################################################################
## Overlaying layers of information
##################################################################
#+end_src
And finally, the third step is to display the different layers of
information in correct order:

#+INDEX: Packages!rasterVis@\texttt{rasterVis}
#+INDEX: Packages!tidyterra@\texttt{tidyterra}  
#+INDEX: Packages!sp@\texttt{sp}  
#+INDEX: Packages!sf@\texttt{sf}  
#+INDEX: Packages!latticeExtra@\texttt{latticeExtra}  
#+INDEX: Packages!ggplot2@\texttt{ggplot2}  
#+INDEX: Packages!RColorBrewer@\texttt{RColorBrewer}  

The =rasterVis= package creates the hill shade layer with the
=levelplot= method for =Raster= objects. The =GrTheme= is modified to
display the sea region with blue color. The result is shown in Figure
ref:fig:cedeiraHSlattice.

#+begin_src R
## The background color of the panel is set to blue to represent the
## sea
hsTheme <- GrTheme(panel.background = list(col = "skyblue3"))

hsLattice <- levelplot(hsCedeira, maxpixels = ncell(hsCedeira),
                       par.settings = hsTheme,
                       margin = FALSE, colorkey = FALSE,
                       xlab = "", ylab = "")
#+end_src

#+RESULTS:


#+begin_src R :results output graphics file :exports results :tangle no :file figs/Spatial/cedeiraHSlattice.pdf
print(hsLattice)
#+end_src

The =tidyterra= package displays the hill shade layer with the
=geom_spatraster= function.

#+begin_src R
greyPal <- rev(brewer.pal(n = 9, name = "Greys"))

ggplot() +
  geom_spatraster(data = hsCedeiraT,
                  show.legend = FALSE) +
  scale_fill_gradientn(colours = greyPal,
                       na.value = "skyblue3") +
  theme_bw()
#+end_src
However, this layer cannot be combined with the next graphics layer
(the DEM layer) because both define the colour scale. This problem can
be solved thanks to the =fill= argument of the =geom_spatraster=
function: when we pass a vector of colours to this argument, the
function will create a layer without mapping to the colour scale of
the graphic. Therefore, we have to build the scale of this layer. The
result is shown in Figure ref:fig:cedeiraHSggplot.

#+begin_src R
## Build a vector of greys based on the Color Brewer pal
greyRamp <- colorRampPalette(greyPal)
greys <- greyRamp(255) ##255 colors, 0 to 254

## Classify the values of the raster in 255 classes
idx <- classify(hsCedeiraT, 255, ## 255 cuts
                include.lowest = TRUE) 
idx <- as.vector(idx)
## Map these classes to the vector of colors
palGreys <- greys[idx + 1] ## 1:255 for indexing

hsGGplot <- geom_spatraster(data = hsCedeiraT,
                  fill = palGreys,
                  ## Plot every cell of the raster
                  maxcell = Inf)
#+end_src

#+begin_src R :results output graphics file :exports results :tangle no :file figs/Spatial/cedeiraHSggplot.pdf
print(ggplot() + hsGGplot)
#+end_src

#+caption: Local topography of Cedeira (Galicia, Spain) displayed with the hill shading technique. label:fig:cedeiraHS
#+begin_figure
#+attr_latex: :options {0.5\textwidth}
#+CAPTION: =lattice= version. label:fig:cedeiraHSlattice
#+begin_subfigure
#+attr_latex: :width 0.8\linewidth 
#+RESULTS:
[[file:figs/Spatial/cedeiraHSlattice.pdf]]
#+end_subfigure
#+attr_latex: :options {0.5\textwidth}
#+CAPTION: =ggplot2= version. label:fig:cedeiraHSggplot
#+begin_subfigure
#+attr_latex: :width 0.8\linewidth 
#+RESULTS:
file:figs/Spatial/cedeiraHSggplot.pdf
#+end_subfigure
#+end_figure

The DEM raster is printed with terrain colors and semitransparency over the hill shade layer. The =lattice= version is shown in Figure ref:fig:cedeiraDEMlattice and the =ggplot2= version in Figure ref:fig:cedeiraDEMggplot.

#+INDEX: Packages!colorspace@\texttt{colorspace}  

#+begin_src R
## DEM with terrain colors and semitransparency
terrainPal <- terrain_hcl(n = 15)
#+end_src


#+begin_src R
## Lattice version
terrainTheme <- rasterTheme(region = terrainPal, 
                            regions = list(alpha = 0.6))

demLattice <- levelplot(demCedeira, maxpixels = ncell(demCedeira),
                        par.settings = terrainTheme,
                        margin = FALSE, colorkey = FALSE)
#+end_src

#+RESULTS:

#+begin_src R :results output graphics file :exports results :file figs/Spatial/cedeiraDEMlattice.pdf
print(demLattice)
#+end_src

#+begin_src R
## ggplot version
demGGplot <- geom_spatraster(data = demCedeiraT,
                             alpha = 0.6,
                             show.legend = FALSE)
terrainScale <- scale_fill_gradientn(colours = terrainPal,
                                     na.value = "skyblue3")
#+end_src

#+RESULTS:

#+begin_src R :results output graphics file :exports results :file figs/Spatial/cedeiraDEMggplot.pdf
print(ggplot() + demGGplot + terrainScale)
#+end_src

#+CAPTION: Local topography of Cedeira (Galicia, Spain). label:fig:cedeiraDEM
#+begin_figure
#+CAPTION: =lattice= version. label:fig:cedeiraDEMlattice
#+attr_latex: :options {0.5\textwidth}
#+begin_subfigure
#+attr_latex: :width 0.8\linewidth 
#+RESULTS:
[[file:figs/Spatial/cedeiraDEMlattice.pdf]]
#+end_subfigure
#+attr_latex: :options {0.5\textwidth}
#+CAPTION: =ggplot2= version. label:fig:cedeiraDEMggplot
#+begin_subfigure
#+attr_latex: :width 0.8\linewidth 
#+RESULTS:
file:figs/Spatial/cedeiraDEMggplot.pdf
#+end_subfigure
#+end_figure

The roads are displayed with auxiliary functions (=sp.road= and =sf_road=) that produces a colored line over a thicker black line, and the town and villages and their names are displayed with the auxiliary functions =sp.places= and =sf_places=.

#+begin_src R
## Auxiliary function to display the roads.

## A thicker black line in the background and a
## thinner one with an appropiate color.

## sp version
sp.road <- function(line, lwd = 6, blwd = 7,
                    col = "indianred1", bcol = "black") {
  sp.lines(line, lwd = blwd, col = bcol)
  sp.lines(line, lwd = lwd, col = col)
}

## sf version
sf_road <- function(line, lwd = 1, blwd = 1.1,
                    col = "indianred1", bcol = "black") {
  list(
    geom_sf(data = line, linewidth = blwd, col = bcol), 
    geom_sf(data = line, linewidth = lwd, col = col)
  )
}
#+end_src

#+begin_src R
##Auxiliary function to display the towns and villages. 

## sp version
sp.places <- function(places, point.size= 0.4, text.size = 0.8) {
  sp.points(places, pch = 19, col = "black",
            cex = point.size, alpha = 0.8)
  sp.text(coordinates(places), places$name,
          pos = 3,
          fontfamily = "Palatino", 
          cex = text.size, col = "black")
}

## sf version
sf_places <- function(places, text_size, point_size, vjust = -1)
{
  list(
    geom_sf(data = places, size = point_size), 
    geom_sf_text(aes(label = name), data = places,
                 size = text_size, vjust = vjust)
  )
}
#+end_src

The final figure is produced superimposing the layers of =sp= objects
with the =+.trellis= mechanism of the =latticeExtra= package (Figure
[[ref:fig:cedeiraOSMlattice]]):

#+begin_src R :results output graphics file :exports both :file figs/Spatial/cedeiraOSMlattice.pdf
## Hill shade and DEM overlaid
hsLattice +
  demLattice +
  ## Roads and places
  layer({
    ## Street and roads
    sp.road(streetsSP, lwd = 1, blwd = 1, col = "white")
    sp.road(unclassifiedSP, lwd = 2, blwd = 2, col = "white")
    sp.road(footwaySP, lwd = 2, blwd = 2, col = "white")
    sp.road(stepsSP, lwd = 2, blwd = 2, col = "white")
    sp.road(tertiarySP, lwd = 4, blwd = 4, col = "palegreen")
    sp.road(secondarySP, lwd = 6, blwd = 6, col = "midnightblue")
    sp.road(primarySP, lwd = 7, blwd = 8, col = "indianred1")
    ## Places except Cedeira town
    sp.places(placesHsp, point.size = 0.4, text.size = 0.8)
    ## Cedeira town
    sp.places(citySP, point.size = 1.2, text.size = 1.5)
  })
#+end_src

or superimposing the layers of =sf= objects with the =+.gg= mechanism
of =ggplot2= (Figure ref:fig:cedeiraOSMggplot):
#+begin_src R :results output graphics file :exports both :file figs/Spatial/cedeiraOSMggplot.pdf
ggplot() +
  hsGGplot +
  demGGplot + terrainScale +
  ## Street and roads
  sf_road(streetsSF, lwd = .4, blwd = .5, col = "white") +
  sf_road(unclassifiedSF, lwd = .4, blwd = .5, col = "white") +
  sf_road(footwaySF, lwd = .4, blwd = .5, col = "white") +
  sf_road(stepsSF, lwd = .4, blwd = .5, col = "white") +
  sf_road(tertiarySF, lwd = .8, blwd = .9, col = "palegreen") +
  sf_road(secondarySF, lwd = .9, blwd = 1, col = "midnightblue") +
  sf_road(primarySF, lwd = 1.1, blwd = 1.2, col = "indianred1") +
  ## Places
  sf_places(placesHsf, point_size = 1, text_size = 3) +
  sf_places(citySF, point_size = 3, text_size = 5) +
  theme_bw() + xlab("") + ylab("")
#+end_src

#+CAPTION: Main roads near Cedeira, Galicia. Local topography is displayed with the hill shading technique. Some places are highlighted. label:fig:cedeiraOSM
#+begin_figure
#+CAPTION: =lattice= version label:fig:cedeiraOSMlattice
#+attr_latex: :options {0.5\textwidth}
#+begin_subfigure
#+attr_latex: :width 0.8\linewidth 
#+RESULTS:
[[file:figs/Spatial/cedeiraOSMlattice.pdf]]
#+end_subfigure

#+CAPTION: =ggplot2= version label:fig:cedeiraOSMggplot
#+attr_latex: :options {0.5\textwidth}
#+begin_subfigure
#+attr_latex: :width 0.8\linewidth 
#+RESULTS:
[[file:figs/Spatial/cedeiraOSMggplot.pdf]]
#+end_subfigure
#+end_figure

* Footnotes

[fn:2] http://www.overpass-api.de/

[fn:1] http://xeocatalogo.xunta.es/geonetwork/srv/gl/main.home
