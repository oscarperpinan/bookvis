#+PROPERTY: header-args :session *R* :cache yes :tangle ../docs/R/osm.R :eval no-export
#+OPTIONS: ^:nil

#+begin_src R :exports none :tangle no
setwd('~/github/bookvis/')
#+end_src

#+begin_src R :exports none  
##################################################################
## Initial configuration
##################################################################
## Clone or download the repository and set the working directory
## with setwd to the folder where the repository is located.
#+end_src

* Reference maps
label:sec:reference

Although I was born in Madrid, Galicia (north of Spain) is a very
special region for me. More precisely, the Cedeira and Valdovi√±o
regions offer a wonderful combination of wild sea, secluded beaches,
and forests. I will show you a map of these marvelous places.

** Retrieving Data from OpenStreetMap
#+begin_src R :exports none
##################################################################
## Retrieving data from OpenStreetMap
##################################################################
#+end_src

The first step is to acquire information from the OpenStreetMap (OSM)
project. There are several packages to extract data from this service
but, while most of them only provide already rendered raster images,
the =osmdata= package enables the use of the raw data with
classes of the packages =sp= and =sf=.

The =osmdata= package obtains data from the overpass API[fn:2], a
read-only API that serves up custom selected parts of the OSM map
data. The first step is specifying the bounding box with the function
=opq=:

#+INDEX: Data!OpenStreetMap
#+INDEX: Packages!osmdata@\texttt{osmdata}

#+begin_src R
library("osmdata")
library("sf")
library("sp")


## Bounding box
xmin <- -8.1
ymin <- 43.62
xmax <- -8
ymax <- 43.7 
cedeiraBB <- c(xmin = xmin, ymin = ymin,
               xmax = xmax, ymax = ymax) 

## Overpass query
cedeiraOPQ <- opq(cedeiraBB)
#+end_src

Next, the query is completed adding the required features with
=add_osm_feature=. The three main arguments of this function are the
overpass query defined with =opq=, the feature =key=, and the =value=
of this feature. Finally, the information contained in the query can
be obtained as a =Spatial*= object with =osmdata_sp=, or as a =sf=
object with =osmdata_sf=. The result is a list with three components,
=osm_points=, =osm_lines=, and =osm_polygons=, containing the
respective spatial object. 

For example, the next code obtains the residential streets in the
region as a list of =Spatial*= objects.

#+begin_src R :results output :exports both
streetsOSM <- add_osm_feature(cedeiraOPQ,
                              key = "highway",
                              value = "residential")

streetsSP <- osmdata_sp(streetsOSM)

print(streetsSP)
#+end_src

#+RESULTS[d459f4bbe11478d2e301df7172c4154d2b6cf2cf]:
: Object of class 'osmdata' with:
:                  $bbox : 43.62,-8.1,43.7,-8
:         $overpass_call : The call submitted to the overpass API
:                  $meta : metadata including timestamp and version numbers
:            $osm_points : 'sp' SpatialPointsDataFrame with 1470 points
:             $osm_lines : 'sp' SpatialLinesDataFrame with 226 lines
:          $osm_polygons : 'sp' SpatialPolygonsDataFrame with 7 polygons
:        $osm_multilines : 'sp' SpatialNADataFrame with 0 multilines
:     $osm_multipolygons : 'sp' SpatialPolygonsDataFrame with 0 multipolygons


Because this procedure is to be repeated several times, I define a
wrapper function that provides a =SpatialLinesDataFrame= object or a
=SpatialPointsDataFrame= object depending on the value of its argument
=type=:
#+begin_src R
spFromOSM <- function(source, key, value, type = 'lines')
{
    osm <- add_osm_feature(source, key, value)
    spdata <- osmdata_sp(osm)
    switch(type,
           lines = spdata$osm_lines,
           points = spdata$osm_points)
}
#+end_src  
and a function that provides a =sf= object:
#+begin_src R
sfFromOSM <- function(bb, key, value, type = 'lines')
{
  source <- opq(bb)
  osm <- add_osm_feature(source, key, value)
  sfdata <- osmdata_sf(osm)
  switch(type,
         lines = st_crop(sfdata$osm_lines, bb),
         points = sfdata$osm_points)
  
}
#+end_src  

The next code uses these functions to obtain the different types of
roads and streets in the region as =SpatialLinesDataFrame= objects:
#+begin_src R 
streetsSP <- spFromOSM(cedeiraOPQ,
                       key = "highway", value = "residential")
primarySP <- spFromOSM(cedeiraOPQ,
                       key = "highway", value = "primary")
secondarySP <- spFromOSM(cedeiraOPQ,
                         key = "highway", value = "secondary")
tertiarySP <- spFromOSM(cedeiraOPQ,
                        key = "highway", value = "tertiary")
unclassifiedSP <- spFromOSM(cedeiraOPQ,
                            key = "highway", value = "unclassified")
footwaySP <- spFromOSM(cedeiraOPQ,
                       key = "highway", value = "footway")
stepsSP <- spFromOSM(cedeiraOPQ,
                     key = "highway", value = "steps")
#+end_src  
and =sf= objects:
#+begin_src R 
streetsSF <- sfFromOSM(cedeiraBB,
                       key = "highway", value = "residential")
primarySF <- sfFromOSM(cedeiraBB,
                       key = "highway", value = "primary")
secondarySF <- sfFromOSM(cedeiraBB,
                         key = "highway", value = "secondary")
tertiarySF <- sfFromOSM(cedeiraBB,
                        key = "highway", value = "tertiary")
unclassifiedSF <- sfFromOSM(cedeiraBB,
                            key = "highway", value = "unclassified")
footwaySF <- sfFromOSM(cedeiraBB,
                       key = "highway", value = "footway")
stepsSF <- sfFromOSM(cedeiraBB,
                     key = "highway", value = "steps")
#+end_src  

A similar procedure can be applied to construct a =SpatialPointsDataFrame=
object with the collection of places with name:
#+begin_src R 
citySP <- spFromOSM(cedeiraOPQ, key = "place",
                    value = "town", type = "points")
placesVsp <- spFromOSM(cedeiraOPQ, key = "place",
                       value = "village", type = "points")

placesHsp <- spFromOSM(cedeiraOPQ, key = "place",
                       value = "hamlet", type = "points")
placesHsp <- subset(placesHsp, as.numeric(population) > 30)
#+end_src  
The =sfFromOSM= function retrieves the same information as =sf= objects:
#+begin_src R 
citySF <- sfFromOSM(cedeiraBB, key = "place",
                    value = "town", type = "points")
placesVsf <- sfFromOSM(cedeiraBB, key = "place",
                       value = "village", type = "points")

placesHsf <- sfFromOSM(cedeiraBB, key = "place",
                       value = "hamlet", type = "points")
placesHsf <- subset(placesHsf, as.numeric(population) > 30)
#+end_src  

** Hill Shading
label:sec:hill-shading-osm
#+begin_src R :exports none
##################################################################
## Hill Shading
##################################################################
#+end_src

#+INDEX: Subjects!Hill shading

The second step is to produce layers to display the topography. A
suitable method is shaded relief or hill shading, previously exposed
in section ref:sec:hill-shading-raster.

The hill shade layer is computed from the slope and aspect layers
derived from a Digital Elevation Model. The DEM of Galicia is
available at the Geonetwork service of the Xunta de Galicia[fn:1]. I
have extracted the data corresponding to the region of interest using
=crop=, and the corresponding files are available at the =data= folder
of the book repository.

#+INDEX: Packages!raster@\texttt{raster}
#+INDEX: Packages!rasterVis@\texttt{rasterVis}
#+INDEX: Data!Geonetwork

#+begin_src R
library("raster")

projCedeira <- projection(city)

demCedeira <- raster('data/Spatial/demCedeira')
projection(demCedeira) <- projCedeira

## Crop the DEM using the bounding box of the OSM data
OSMextent <- extent(extendrange(c(xmin, xmax)),
                    extendrange(c(ymin, ymax)))
demCedeira <- crop(demCedeira, OSMextent)

## Discard values below sea level
demCedeira[demCedeira <= 0] <- NA
#+end_src

The =slope= and =aspect= layers are computed with the =terrain=
function, and the hill shade layer is derived with these layers for a
fixed sun position. 

#+begin_src R 
slope <- terrain(demCedeira, 'slope')
aspect <- terrain(demCedeira, 'aspect')
hsCedeira <- hillShade(slope = slope, aspect = aspect,
                       angle = 20, direction = 30)
#+end_src

** Overlaying Layers of Information
#+begin_src R :exports none
##################################################################
## Overlaying layers of information
##################################################################
#+end_src
And finally, the third step is to display the different layers of
information in correct order:

#+INDEX: Packages!rasterVis@\texttt{rasterVis}  
#+INDEX: Packages!sp@\texttt{sp}  
#+INDEX: Packages!sf@\texttt{sf}  
#+INDEX: Packages!latticeExtra@\texttt{latticeExtra}  
#+INDEX: Packages!ggplot2@\texttt{ggplot2}  
#+INDEX: Packages!colorspace@\texttt{colorspace}  
#+INDEX: Packages!RColorBrewer@\texttt{RColorBrewer}  

#+begin_src R
library("rasterVis")
#+end_src

- The hill shade layer is created with the =levelplot= method for
  =Raster= objects defined in the =rasterVis= package. The =GrTheme=
  is modified to display the sea region with blue color.

#+begin_src R
## The background color of the panel is set to blue to represent the
## sea
hsTheme <- GrTheme(panel.background = list(col = "skyblue3"))
#+end_src

- The DEM raster is printed with terrain colors and semitransparency
  over the hill shade layer.

#+begin_src R
library("colorspace")

## DEM with terrain colors and semitransparency
terrainPal <- terrain_hcl(n = 15)

terrainTheme <- rasterTheme(region = terrainPal, 
                            regions = list(alpha = 0.6))
#+end_src

- The roads are displayed with auxiliary functions (=sp.road= and
  =sf_road=) that produces a colored line over a thicker black line,
  and the town and villages and their names are displayed with the
  auxiliary functions =sp.places= and =sf_places=.

#+begin_src R
## Auxiliary function to display the roads.

## A thicker black line in the background and a
## thinner one with an appropiate color.

## sp version
sp.road <- function(line, lwd = 6, blwd = 7,
                    col = "indianred1", bcol = "black") {
  sp.lines(line, lwd = blwd, col = bcol)
  sp.lines(line, lwd = lwd, col = col)
}

## sf version
sf_road <- function(line, lwd = 1, blwd = 1.1,
                    col = "indianred1", bcol = "black") {
  list(
    geom_sf(data = line, linewidth = blwd, col = bcol), 
    geom_sf(data = line, linewidth = lwd, col = col)
  )
}
#+end_src

#+begin_src R
##Auxiliary function to display the towns and villages. 

## sp version
sp.places <- function(places, point.size= 0.4, text.size = 0.8) {
  sp.points(places, pch = 19, col = "black",
            cex = point.size, alpha = 0.8)
  sp.text(coordinates(places), places$name,
          pos = 3,
          fontfamily = "Palatino", 
          cex = text.size, col = "black")

## sf version
sf_place <- function(places, text_size, point_size, vjust = -1)
{
  list(
    geom_sf(data = places, size = point_size), 
    geom_sf_text(aes(label = name), data = places,
                 size = text_size, vjust = vjust)
  )
}
#+end_src

The final figure is produced superimposing the layers of =sp= objects
with the =+.trellis= mechanism of the =latticeExtra= package (Figure
[[ref:fig:cedeiraOSM]]):
#+begin_src R :results output graphics file :exports both :file figs/Spatial/cedeiraOSM.pdf
library(latticeExtra)

## Hill shade and DEM overlaid
levelplot(hsCedeira, maxpixels = ncell(hsCedeira),
          par.settings = hsTheme,
          margin = FALSE, colorkey = FALSE,
          xlab = "", ylab = "") +
  levelplot(demCedeira, maxpixels = ncell(demCedeira),
            par.settings = terrainTheme) +
  ## Roads and places
  layer({
    ## Street and roads
    sp.road(streetsSP, lwd = 1, blwd = 1, col = "white")
    sp.road(unclassifiedSP, lwd = 2, blwd = 2, col = "white")
    sp.road(footwaySP, lwd = 2, blwd = 2, col = "white")
    sp.road(stepsSP, lwd = 2, blwd = 2, col = "white")
    sp.road(tertiarySP, lwd = 4, blwd = 4, col = "palegreen")
    sp.road(secondarySP, lwd = 6, blwd = 6, col = "midnightblue")
    sp.road(primarySP, lwd = 7, blwd = 8, col = "indianred1")
    ## Places except Cedeira town
    sp.places(placesHsp, point.size = 0.4, text.size = 0.8)
    sp.places(placesVsp, point.size = 0.6, text.size = 1)
    ## Cedeira town
    sp.places(citySP, point.size = 1.2, text.size = 1.5)
  })
#+end_src
#+CAPTION: Main roads near Cedeira, Galicia. Local topography is displayed with the hill shading technique. Some places are highlighted. label:fig:cedeiraOSM
#+RESULTS[e4e8733abcc4f9e3d01978c2e88923d5c2a8fe1e]:
[[file:figs/Spatial/cedeiraOSM.pdf]]

or superimposing the layers of =sf= objects with the =+.gg= mechanism
of =ggplot2=:
#+begin_src R 
library(ggplot2)

## DEM
gplot(demCedeira,
      palette = scale_fill_gradientn(colours = terrainPal),
      show.legend = FALSE) + 
  ## Street and roads
  sf_road(streetsSF, lwd = .4, blwd = .5, col = "white") +
  sf_road(unclassifiedSF, lwd = .4, blwd = .5, col = "white") +
  sf_road(footwaySF, lwd = .4, blwd = .5, col = "white") +
  sf_road(stepsSF, lwd = .4, blwd = .5, col = "white") +
  sf_road(tertiarySF, lwd = .8, blwd = .9, col = "palegreen") +
  sf_road(secondarySF, lwd = .9, blwd = 1, col = "midnightblue") +
  sf_road(primarySF, lwd = 1.1, blwd = 1.2, col = "indianred1") +
  ## Places
  sf_place(placesHsf, point_size = 1, text_size = 3) +
  sf_place(placesVsf, point_size = 2, text_size = 4) +
  sf_place(citySF, point_size = 3, text_size = 5)
#+end_src


* Footnotes

[fn:2] http://www.overpass-api.de/

[fn:1] http://xeocatalogo.xunta.es/geonetwork/srv/gl/main.home
