#+PROPERTY:  header-args :session *R* :tangle ../docs/R/raster.R :eval no-export
#+OPTIONS: ^:nil

#+begin_src R :exports none :tangle no
setwd('~/github/bookvis/')
#+end_src


#+begin_src R :exports none  
##################################################################
## Initial configuration
##################################################################
## Clone or download the repository and set the working directory
## with setwd to the folder where the repository is located.
#+end_src

* Quantitative Data
label:sec:quantitative_raster
#+begin_src R :exports none
##################################################################
## Quantitative data
##################################################################
#+end_src

#+INDEX: Data!CM SAF
#+INDEX: Data!Solar radiation

#+INDEX: Packages!raster@\texttt{raster}
#+INDEX: Packages!terra@\texttt{terra}
#+INDEX: Packages!rasterVis@\texttt{rasterVis}

As an example of quantitative data, this section displays the
distribution of annual solar irradiation over the Iberian peninsula
using the estimates from CM SAF. Read Chapter ref:cha:dataSpatial for
details about this dataset.

#+begin_src R
library("raster")
library("terra")
library("rasterVis")

SISavr <- raster("data/Spatial/SISav.nc")

SISavt <- rast("data/Spatial/SISav.nc")
#+end_src

The raster of annual averages of solar irradiation estimated by CM SAF
can be easily displayed with the =levelplot= method of the =rasterVis=
package. Figure [[ref:fig:levelplotCMSAF]] illustrates this raster with
marginal graphics to show the column (longitude) and row (latitude)
summaries of the raster object. The summary is computed with the
function defined by =FUN.margin= (which uses =mean= as the default
value).

#+INDEX: Subjects!Sequential palette

#+begin_src R :results output graphics :exports both :file figs/Spatial/leveplotSISavOrig.png :width 4000 :height 4000 :res 600
levelplot(SISavr)
#+end_src

#+CAPTION: Annual average of solar radiation displayed with a sequential palette. label:fig:levelplotCMSAF
#+RESULTS:
[[file:figs/Spatial/leveplotSISavOrig.png]]

Although the solar irradiation distribution reveals the physical
structure of the region, it is recommended to add the geographic
context with a layer of administrative boundaries. These boundaries can be retrieved from the Natural Earth service with the =rnaturalearth= package 

#+INDEX: Subjects!Background map
#+INDEX: Packages!rnaturalearth@\texttt{rnaturalearth}
#+INDEX: Packages!sf@\texttt{sf}

#+begin_src R 
library("rnaturalearth")

boundarySF <- ne_countries(country = "spain", scale = 50)
## Crop to the limits of the raster object
boundarySF <- st_crop(boundarySF,
                      xmin = xmin(SISavt), ymin = ymin(SISavt),
                      xmax = xmax(SISavt), ymax = ymax(SISavt))
#+end_src

These boundaries are superimposed on the main map with the =layer= and
=sp.lines= functions in the =lattice= system (Figure
ref:fig:levelplotCMSAF_boundaries), and with =geom_sf= in the
=ggplot2= system.

#+begin_src R
##ggplot2 version
library(ggplot2)

gplot(SISavt) +
  geom_sf(data = boundarySF, fill = "transparent") +
  coord_sf(expand = FALSE) + 
  xlab("Longitude") + ylab("Latitude")
#+end_src

#+INDEX: Packages!sp@\texttt{sp}
#+INDEX: Packages!latticeExtra@\texttt{latticeExtra}

#+begin_src R :results output graphics :exports both :file figs/Spatial/leveplotSISavBoundaries.png :width 4000 :height 4000 :res 600
## lattice version
library(latticeExtra)

## Convert the sf object to sp
boundarySP <- as(boundarySF, "Spatial")

## Display the data ...
levelplot(SISavt) +
  ## ... and overlay the SpatialLines object
  layer(sp.lines(boundarySP,
                 lwd = 0.5))     
#+end_src

#+CAPTION: Annual average of solar radiation with administrative boundaries. label:fig:levelplotCMSAF_boundaries
#+RESULTS:
[[file:figs/Spatial/leveplotSISavBoundaries.png]]


** Hill Shading
label:sec:hill-shading-raster
#+begin_src R :exports none
##################################################################
## Hill shading
##################################################################
#+end_src
A frequent method to improve the display of meteorological rasters is
the hill shading or shaded relief technique, a method of representing
relief on a map by depicting the shadows that would be cast by high
ground if light comes from a certain sun position (Figure
ref:fig:hillShading). The hill shade layer can be computed from the
slope and aspect layers derived from a Digital Elevation Model
(DEM). This layer will underlay the DEM raster, which will be printed
using semitransparency.

\nomenclature{DEM}{Digital Elevation Model.}
#+INDEX: Subjects!Hill shading
#+INDEX: Packages!geodata@\texttt{geodata}

The procedure is as follows:

- Download a Digital Elevation Model (DEM) from the DIVA-GIS service with the =geodata= package, obtaining a =SpatRaster= object.

#+INDEX: Data!DIVA-GIS
#+INDEX: Packages!geodata@\texttt{geodata}

#+begin_src R
library(geodata)

DEM <- elevation_30s("ESP", path = tempdir())
#+end_src

- Compute the hill shade raster with =terrain= and =shade= from the
  =terra= package, or with =terrain= and =hillShade= from =raster=
  package, with a certain angle and direction. 

#+begin_src R
slope <- terrain(DEM, "slope", unit = "radians")
aspect <- terrain(DEM, "aspect", unit = "radians")
hs <- shade(slope = slope, aspect = aspect,
            angle = 60, direction = 45)
#+end_src

#+begin_src R :eval no-export
DEMr <- raster(DEM)
sloper <- terrain(DEMr, "slope")
aspectr <- terrain(DEMr, "aspect")
hsr <- hillShade(slope = sloper, aspect = aspectr,
                 angle = 60, direction = 45)
#+end_src

- Combine the result with the previous map using semitransparency.

#+begin_src R :results output graphics :exports both :width 2000 :height 2000 :res 300 :file figs/Spatial/hillShading.png
## hillShade theme: gray colors and semitransparency
hsTheme <- GrTheme(regions = list(alpha = 0.5))

levelplot(SISavt,
          par.settings = YlOrRdTheme,
          margin = FALSE, colorkey = FALSE) +
  ## Overlay the hill shade raster
  levelplot(hs, par.settings = hsTheme, maxpixels = 1e6) +
  ## and the countries boundaries
  layer(sp.lines(boundarySP, lwd = 0.5))
#+end_src

#+CAPTION: Hill shading of annual average of solar radiation. label:fig:hillShading
#+RESULTS:
[[file:figs/Spatial/hillShading.png]]


** Diverging Palettes
#+begin_src R :exports none
##################################################################
## Diverging palettes
##################################################################
#+end_src

Next, instead of displaying the absolute values of each cell, we will
analyze the differences between each cell and the global average
value. This average is computed with the =global= function in the
=terra= package, and with =cellStats= in the =raster= package, and
substracted from the original raster.

#+begin_src R
meanRad <- global(SISavt, "mean")
meanRad <- as.numeric(meanRad)
SISavt <- SISavt - meanRad
#+end_src

#+begin_src R :eval no-export
meanRad <- cellStats(SISavr, "mean")
SISavr <- SISavr - meanRad
#+end_src

Figure ref:fig:xyplotSISav displays the relation between these scaled
values and latitude (=y=), with five different groups defined by the
longitude (=cut(x, 5)=). It is evident that larger irradiation values
are associated with lower latitudes. However, there is no such clear
relation between irradiation and longitude.

#+INDEX: Packages!viridisLite@\texttt{viridisLite}

#+begin_src R :results output graphics :exports both :width 2000 :height 2000 :res 300 :file figs/Spatial/xyplotSISav.png 
library(viridisLite)

xyplot(layer ~ y, data = SISavt,
       groups = cut(x, 5),
       par.settings = rasterTheme(symbol = magma(n = 5,
                                                 begin = 0, end = 0.9,
                                                 direction = -1)),
       xlab = "Latitude", ylab = "Solar radiation (scaled)",  
       auto.key = list(space = "right",
                       title = "Longitude",
                       cex.title = 1.3))
#+end_src

#+CAPTION: Relation between scaled annual average radiation and latitude for several longitude groups. label:fig:xyplotSISav
#+RESULTS:
[[file:figs/Spatial/xyplotSISav.png]]

#+INDEX: Subjects!Diverging palette

Numerical information ranging in an interval including a neutral
value is commonly displayed with diverging palettes. These
palettes represent neutral classes with light colors, while low
and high extremes of the data range are highlighted using dark
colors with contrasting hues. I use the Purple-Orange palette from
ColorBrewer with purple for positive values and orange for
negative values. In order to underline the position of the
interval containing zero, the center color of this palette is
substituted with pure white. The resulting palette is displayed in
Figure ref:fig:showDivPal with the custom =showPal=
function. The corresponding correspondent raster map produced with this palette
is displayed in Figure ref:fig:divPal_SISav_naive.  Although
extreme positive and negative values can be easily discriminated,
the zero value is not associated with white because the data range
is not symmetrical around zero.

#+INDEX: Subjects!Visual discrimination
#+INDEX: Packages!RColorBrewer@\texttt{RColorBrewer}

#+begin_src R :results output graphics :exports both :file figs/Spatial/showDivPal.pdf
library(RColorBrewer)

divPal <- brewer.pal(n = 9, "PuOr")
divPal[5] <- "#FFFFFF"

showPal <- function(pal)
{
    N <- length(pal)
    image(1:N, 1, as.matrix(1:N), col = pal,
          xlab = "", ylab = "",
          xaxt = "n", yaxt = "n",
          bty = "n")
}

showPal(divPal)
#+end_src

#+CAPTION: Purple-Orange diverging palette using white as middle color. label:fig:showDivPal
#+ATTR_LaTeX: :height 0.3\textheight
#+RESULTS:
[[file:figs/Spatial/showDivPal.pdf]]


#+begin_src R :results output graphics :exports both :file figs/Spatial/divPal_SISav_naive.png :width 4000 :height 4000 :res 600
divTheme <- rasterTheme(region = divPal)

levelplot(SISavt, contour = TRUE, par.settings = divTheme)
#+end_src

#+CAPTION: Asymmetric raster data (scaled annual average irradiation) displayed with a symmetric diverging palette. label:fig:divPal_SISav_naive
#+RESULTS:
[[file:figs/Spatial/divPal_SISav_naive.png]]

The solution is to connect the symmetrical color palette with the
asymmetrical data range. The first step is to create a set of
breaks such that the zero value is the center of one of the
intervals.
#+begin_src R 
rng <- range(SISavt[])
## Number of desired intervals
nInt <- 15
## Increment corresponding to the range and nInt
inc0 <- diff(rng)/nInt
## Number of intervals from the negative extreme to zero
n0 <- floor(abs(rng[1])/inc0)
## Update the increment adding 1/2 to position zero in the center of an interval
inc <- abs(rng[1])/(n0 + 1/2)
## Number of intervals from zero to the positive extreme
n1 <- ceiling((rng[2]/inc - 1/2) + 1)
## Collection of breaks
breaks <- seq(rng[1], by = inc, length= n0 + 1 + n1)
#+end_src


The next step is to compute the midpoints of each interval. These
points represent the data belonging to each interval, and their value
will be connected with a color of the palette.

#+INDEX: Subjects!Class Intervals

#+begin_src R 
## Midpoints computed with the median of each interval
idx <- findInterval(SISavt[], breaks, rightmost.closed = TRUE)
mids <- tapply(SISavt[], idx, median)
## Maximum of the absolute value both limits
mx <- max(abs(breaks))
#+end_src

A simple method to relate the palette and the intervals is with a
straight line such that a point is defined by the absolute maximum
value, (=(mx, 1)=), and another point by zero, (=(0, 0.5)=).  Why are
we using the interval [0, 1] as the =y=-coordinate of this line, and
why is 0.5 the result of zero? The reason is that the input of the
=break2pal= function will be the result of =colorRamp=, a function
that creates another interpolating function which maps colors with
values between 0 and 1. Therefore, a new palette is created,
extracting colors from the original palette, such that the central
color (white) is associated with the interval containing zero. This
palette is displayed in Figure ref:fig:showBreak2Pal.

The raster map produced with this new palette is displayed in Figure
ref:fig:divPalSISav. Now zero is clearly associated with the white
color.

#+begin_src R :results output graphics :exports both :file figs/Spatial/showBreak2Pal.pdf
break2pal <- function(x, mx, pal){
    ## x = mx gives y = 1
    ## x = 0 gives y = 0.5
    y <- 1/2*(x/mx + 1)
    rgb(pal(y), maxColorValue = 255)
}

## Interpolating function that maps colors with [0, 1]
## rgb(divRamp(0.5), maxColorValue=255) gives "#FFFFFF" (white)
divRamp <- colorRamp(divPal)
## Diverging palette where white is associated with the interval
## containing the zero
pal <- break2pal(mids, mx, divRamp)
showPal(pal)
#+end_src

#+CAPTION: Modified diverging palette related with the asymmetrical raster data. label:fig:showBreak2Pal
#+ATTR_LaTeX: :height 0.3\textheight
#+RESULTS:
[[file:figs/Spatial/showBreak2Pal.pdf]]


#+begin_src R :results output graphics :exports both :file figs/Spatial/divPalSISav.png :width 4000 :height 4000 :res 600
levelplot(SISavt,
          par.settings = rasterTheme(region = pal),
          at = breaks, contour = TRUE)
#+end_src

#+CAPTION: Asymmetric raster data (scaled annual average irradiation) displayed with a modified diverging palette. label:fig:divPalSISav
#+RESULTS:
[[file:figs/Spatial/divPalSISav.png]]


It is interesting to note two operations carried out internally by
the =lattice= package. First, the =custom.theme= function (used by
=rasterTheme=) creates a new palette with 100 colors using
=colorRampPalette= to interpolate the palette passed as an
argument. Second, the =level.colors= function makes the
arrangement between intervals and colors. If this function
receives more colors than intervals, it chooses a subset of the
palette disregarding some of the intermediate colors. Therefore,
because this function will receive 100 colors from =par.settings=, it
is difficult to control exactly which colors of our original
palette will be represented.

An alternative way for finer control is to fill the =regions$col=
component of the theme with our palette after it has been created
(Figure ref:fig:divPal_SISav_regions).

#+begin_src R :results output graphics :exports both :file figs/Spatial/divPalSISav_regions.png :width 4000 :height 4000 :res 600
divTheme <- rasterTheme(regions = list(col = pal))

levelplot(SISavt,
          par.settings = divTheme,
          at = breaks,
          contour = TRUE)
#+end_src

#+CAPTION: Same as Figure ref:fig:divPalSISav but colors are assigned directly to the =regions$col= component of the theme. label:fig:divPal_SISav_regions
#+RESULTS:
[[file:figs/Spatial/divPalSISav_regions.png]]

A final improvement to this map is to compute the intervals using a
classification algorithm with the =classInt= package. With this
approach it is likely that zero will not be perfectly centered in its
corresponding interval. The remaining code is exactly the same as
above, replacing the =breaks= vector with the result of the
=classIntervals= function. Figure ref:fig:divPalSISav_classInt
displays the result.


#+INDEX: Packages!classInt@\texttt{classInt}
#+INDEX: Subjects!Class Intervals

#+begin_src R 
library("classInt")

cl <- classIntervals(SISavt[], style = "kmeans")
breaks <- cl$brks
#+end_src

#+begin_src R
## Repeat the procedure previously exposed, using the 'breaks' vector
## computed with classIntervals
idx <- findInterval(SISavt[], breaks, rightmost.closed = TRUE)
mids <- tapply(SISavt[], idx, median)

mx <- max(abs(breaks))
pal <- break2pal(mids, mx, divRamp)
#+end_src

#+begin_src R
## Modify the vector of colors in the 'divTheme' object
divTheme$regions$col <- pal
#+end_src

#+begin_src R :results output graphics :exports both :file figs/Spatial/divPalSISav_classInt.png :width 4000 :height 4000 :res 600
levelplot(SISavt,
          par.settings = divTheme,
          at = breaks,
          contour = TRUE)
#+end_src

#+CAPTION: Same as Figure ref:fig:divPal_SISav_regions but defining intervals with the optimal classification method. label:fig:divPalSISav_classInt
#+RESULTS:
[[file:figs/Spatial/divPalSISav_classInt.png]]


* Categorical Data
#+begin_src R :exports none
##################################################################
## Categorical data
##################################################################
#+end_src

Land cover is the observed physical cover on the Earth's surface. A
set of seventeen different categories is commonly used. Using
satellite observations, it is possible to map where on Earth each of
these seventeen land surface categories can be found and how these
land covers change over time.

This section illustrates how to read and display rasters with
categorical information using information from the NEO-NASA
project. Read Chapter ref:cha:dataSpatial for details about these
datasets.

After the land cover and population density files have been
downloaded, two =RasterLayer= objects can be created with the =raster=
package or two =SpatRaster= objects with the =terra package=. Both
files are read, their geographical extent reduced to the area of India
and China, and cleaned (=99999= cells are replaced with =NA=).

#+INDEX: Data!NASA EOS
#+INDEX: Data!Population density
#+INDEX: Data!Land cover

#+INDEX: Packages!raster@\texttt{raster}
#+INDEX: Packages!terra@\texttt{terra}

#+begin_src R
## raster
myExtR <- extent(65, 135, 5, 55)

popR <- raster("data/Spatial/875430rgb-167772161.0.FLOAT.TIFF")
popR <- crop(popR, myExtR)
popR[popR==99999] <- NA

landClassR <- raster("data/Spatial/241243rgb-167772161.0.TIFF")
landClassR <- crop(landClassR, myExtR)
#+end_src

#+begin_src R
## terra
myExtT <- ext(65, 135, 5, 55)

popT <- rast("data/Spatial/875430rgb-167772161.0.FLOAT.TIFF")
names(popT) <- "population"
popT <- crop(popT, myExtT)
popT[popT==99999] <- NA

landClassT <- rast("data/Spatial/241243rgb-167772161.0.TIFF")
names(landClassT) <- "landClass"
landClassT <- crop(landClassT, myExtT)

#+end_src
Each land cover type is designated with a different key: the sea is
labeled with 0; forests with 1 to 5; shrublands, grasslands, and
wetlands with 6 to 11; agriculture and urban lands with 12 to 14; and
snow and barren with 15 and 16.  These four groups (sea is replaced by
=NA=) will be the levels of the categorical raster. The =raster=
package includes the =ratify= method to define a layer as categorical
data, filling it with integer values associated to a Raster Attribute
Table (RAT).

#+begin_src R
landClassR[landClassR %in% c(0, 254)] <- NA
## Only four groups are needed:
## Forests: 1:5
## Shrublands, etc: 6:11
## Agricultural/Urban: 12:14
## Snow: 15:16
landClassR <- cut(landClassR, c(0, 5, 11, 14, 16))
## Add a Raster Attribute Table and define the raster as categorical data
landClassR <- ratify(landClassR)
## Configure the RAT: first create a RAT data.frame using the
## levels method; second, set the values for each class (to be
## used by levelplot); third, assign this RAT to the raster
## using again levels
rat <- levels(landClassR)[[1]]
rat$classes <- c("Forest", "Land", "Urban", "Snow")
levels(landClassR) <- rat
#+end_src

#+begin_src R
landClassT[landClassT %in% c(0, 254)] <- NA
landClassT <- classify(landClassT, c(0, 5, 11, 14, 16))

rat <- levels(landClassT)[[1]]
names(rat) <- c("ID", "classes")
rat$classes <- c("Forest", "Land", "Urban", "Snow")
levels(landClassT) <- rat
#+end_src

This categorical raster can be displayed with the =levelplot= method
of the =rasterVis= package. Previously, a theme is defined with the
background color set to =lightskyblue1= to display the sea areas
(filled with =NA= values), and the region palette is defined with
adequate colors (Figure ref:fig:landClass).


#+INDEX: Packages!rasterVis@\texttt{rasterVis}
#+INDEX: Subjects!Qualitative palette

#+begin_src R
qualPal <- c("palegreen4", # Forest
             "lightgoldenrod", # Land
             "indianred4", # Urban
             "snow3")      # Snow

qualTheme <- rasterTheme(region = qualPal,
                         panel.background = list(col = "lightskyblue1")
                         )
#+end_src

#+RESULTS:

#+begin_src R :results output graphics :exports both :file figs/Spatial/landClass.png :width 4000 :height 4000 :res 600  
levelplot(landClassT, maxpixels = 3.5e5,
          par.settings = qualTheme)

#+end_src

#+CAPTION: Land cover raster (categorical data). label:fig:landClass
#+RESULTS:
[[file:figs/Spatial/landClass.png]]

Let's explore the relation between the land cover and population
density rasters. Figure ref:fig:populationNASA displays this
latter raster using a logarithmic scale, defined with =zscaleLog=. 

#+begin_src R :results output graphics :exports both :file figs/Spatial/populationNASA.png :width 4000 :height 4000 :res 600
pPop <- levelplot(popT, zscaleLog = 10,
                  par.settings = BTCTheme,
                  maxpixels = 3.5e5)
pPop
#+end_src

#+CAPTION: Population density raster. label:fig:populationNASA
#+RESULTS:
[[file:figs/Spatial/populationNASA.png]]

Both rasters can be joined together with the =stack= method to create
a new =RasterStack= object, or with =c= to create a multilayer
=SpatStat= object. Figure ref:fig:histogramLandClass displays the
distribution of the logarithm of the population density associated to
each land class.

#+begin_src R
## Join the RasterLayer objects to create a RasterStack object.
s <- stack(popR, landClassR)
names(s) <- c("pop", "landClass")

## Join the SpatRaster objects to create a multilayer object.
st <- c(popT, landClassT)
names(st) <- c("pop", "landClass")

#+end_src

#+begin_src R :results output graphics :exports both :file figs/Spatial/histogramLandClass.pdf
densityplot(~log10(pop), ## Represent the population
            groups = landClass, ## grouping by land classes
            data = s,
            ## Do not plot points below the curves
            plot.points = FALSE)
#+end_src

#+CAPTION: Distribution of the logarithm of the population density associated to each land class. label:fig:histogramLandClass
#+RESULTS:
[[file:figs/Spatial/histogramLandClass.pdf]]


* \floweroneleft  Bivariate Legend
#+begin_src R :exports none
##################################################################
## Bivariate legend
##################################################################
#+end_src
We can reproduce the code used to create the multivariate
choropleth (Section ref:sec:multiChoropleth) using the
=levelplot= function from the =rasterVis= package. Again, the
result is a list of =trellis= objects. Each of these objects is
the representation of the population density in a particular land
class. 

#+INDEX: Subjects!Sequential palette
#+INDEX: Subjects!Qualitative palette

#+begin_src R
classes <- rat$classes
nClasses <- length(classes)
#+end_src

#+begin_src R
logPopAt <- c(0, 0.5, 1.85, 4)

nIntervals <- length(logPopAt) - 1
#+end_src

#+begin_src R
multiPal <- sapply(1:nClasses, function(i)
{
    colorAlpha <- adjustcolor(qualPal[i], alpha = 0.4)
    colorRampPalette(c(qualPal[i],
                       colorAlpha),
                     alpha = TRUE)(nIntervals)
})
#+end_src

#+begin_src R 
pList <- lapply(1:nClasses, function(i){
    landSub <- landClassR
    ## Those cells from a different land class are set to NA...
    landSub[!(landClassR == i)] <- NA
    ## ... and the resulting raster masks the population raster
    popSub <- mask(popR, landSub)
    ## Palette
    pal <- multiPal[, i]

    pClass <- levelplot(log10(popSub),
                        at = logPopAt,
                        maxpixels = 3.5e5,
                        col.regions = pal,
                        colorkey = FALSE,
                        margin = FALSE)
})
#+end_src

The =+.trellis= function of the =latticeExtra= package with =Reduce=
superposes the elements of this list and produces a =trellis=
object. 

#+begin_src R
p <- Reduce('+', pList)
#+end_src

#+RESULTS:

#+INDEX: Packages!grid@\texttt{grid}

The legend is created with =grid.raster= and =grid.text=, following the same procedure exposed in section ref:sec:multiChoropleth. 
#+begin_src R
library("grid")

legend <- layer(
{
    ## Center of the legend (rectangle)
    x0 <- 125
    y0 <- 22
    ## Width and height of the legend
    w <- 10
    h <- w / nClasses * nIntervals
    ## Legend
    grid.raster(multiPal, interpolate = FALSE,
                      x = unit(x0, "native"),
                      y = unit(y0, "native"),
                width = unit(w, "native"))
    ## Axes of the legend
    ## x-axis (qualitative variable)
    grid.text(classes,
              x = unit(seq(x0 - w * (nClasses -1)/(2*nClasses),
                           x0 + w * (nClasses -1)/(2*nClasses),
                           length = nClasses),
                       "native"),
              y = unit(y0 + h/2, "native"),
              just = "bottom",
              rot = 10,
              gp = gpar(fontsize = 6))
    ## y-axis (quantitative variable)
    yLabs <- paste0("[",
                    paste(logPopAt[-nIntervals],
                          logPopAt[-1], sep = ","),
                    "]")
    grid.text(yLabs,
              x = unit(x0 + w/2, "native"),
              y = unit(seq(y0 - h * (nIntervals -1)/(2*nIntervals),
                           y0 + h * (nIntervals -1)/(2*nIntervals),
                           length = nIntervals),
                       "native"),
              just = "left",
              gp = gpar(fontsize = 6))

})
#+end_src

#+RESULTS:

Figure ref:fig:popLandClass displays the result with the legend.
#+begin_src R :results output graphics :exports both :width 2000 :height 2000 :res 300 :file figs/Spatial/popLandClass.png
p + legend
#+end_src

#+CAPTION: Population density for each land class (multivariate raster). label:fig:popLandClass
#+RESULTS:
[[file:figs/Spatial/popLandClass.png]]

* Interactive Graphics
** 3D Visualization label:sec:3dvisualization
#+begin_src R :exports none
##################################################################
## 3D visualization
##################################################################
#+end_src
An alternative method for a DEM is 3D visualization where the user can
rotate or zoom the figure. This solution is available thanks to the
=rgl= package, which provides functions for 3D interactive
graphics. The =plot3D= function in the =rasterVis= package is a
wrapper to this package for =RasterLayer= objects (Figure ref:fig:DEM_rgl).

#+INDEX: Packages!rgl@\texttt{rgl}
#+INDEX: Subjects!3D visualization
#+INDEX: Subjects!STL
\nomenclature{STL}{File format that encodes the surface geometry of a 3D object using tessellation.}

#+begin_src R :eval no-export
plot3D(DEMr, maxpixels = 5e4)
#+end_src

#+CAPTION: 3D visualization of a Digital Elevation Model. label:fig:DEM_rgl
[[file:figs/Spatial/DEM_rgl.png]]

The output scene can be exported to several formats such as =STL= with
=writeSTL=, a format commonly used in 3D printing.

#+begin_src R :eval no-export
library(rgl)

writeSTL("docs/images/rgl/DEM.stl")
#+end_src

** Mapview [[label:mapview_raster]]
#+begin_src R :exports none
##################################################################
## mapview
##################################################################
#+end_src

#+INDEX: Packages!mapview@\texttt{mapview}
#+INDEX: Subjects!Interactive visualization
The package =mapview= is able to work with =Raster*= objects. Thus, the =SISavr= object can be easily displayed in a interactive map with next code. However, it must be noted that, unlike with vector data (Sections ref:sec:mapview_bubble and ref:sec:interactive_choropleth), the interactivity of this map is restricted to zoom and movement. The mouse hovering or click does not produce any result.

#+begin_src R
library("mapview")

mvSIS <- mapview(SISavr, legend = TRUE)
#+end_src

This map can be improved with another layer of information, the name and location of the meteorological stations of the SIAR network. This information is stored in the file =SIAR.csv=. 
#+INDEX: Data!SIAR

#+begin_src R
SIAR <- read.csv("data/Spatial/SIAR.csv")
#+end_src

These points can be encoded as a =SpatialPointsDataFrame= object with the =sp= package:
#+begin_src R :eval no-export
spSIAR <- SpatialPointsDataFrame(coords = SIAR[, c("lon", "lat")], 
                                 data = SIAR,
                                 proj4str = CRS(projection(SISavr)))
#+end_src
or a =sf= object:
#+begin_src R
sfSIAR <- st_as_sf(SIAR,
                   coords = c("lon", "lat"),
                   crs = crs(SISavt))

#+end_src

Both objects, as shown in section ref:sec:mapview_bubble, can be displayed with =mapview=. The resulting map is reactive to mouse hovering and click.
#+begin_src R
mvSIAR <- mapview(sfSIAR,
                  label = sfSIAR$Estacion)
#+end_src

Both layers of information can be combined with the =+= operator. Figure ref:fig:mapview_CMSAF_SIAR shows a snapshot of this interactive map.
#+begin_src R
mvSIS + mvSIAR
#+end_src

#+CAPTION: Snapshot of the interactive map produced with =mapview= combining a =RasterLayer= and a =SpatialPointsDataFrame= objects. label:fig:mapview_CMSAF_SIAR
file:figs/Spatial/mapview_CMSAF_SIAR.png
