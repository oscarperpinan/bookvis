#+PROPERTY: header-args :session *R* :tangle ../docs/R/bubble.R :eval no-export
#+OPTIONS: ^:nil

#+begin_src R :exports none :tangle no
setwd("~/github/bookvis/")
#+end_src


#+begin_src R :exports none  
##################################################################
## Initial configuration
##################################################################
## Clone or download the repository and set the working directory
## with setwd to the folder where the repository is located.
 
library("lattice")
library("ggplot2")
## latticeExtra must be loaded after ggplot2 to prevent masking of its
## `layer` function.
library("latticeExtra")

source("configLattice.R")
##################################################################

#+end_src

#+RESULTS:

* Introduction

In this chapter we display data from a grid of sensors belonging to
the Integrated Air Quality system of the Madrid City Council (Section
ref:sec:airQualityData) with circles as the proportional symbol, and
range grading as the scaling method. The objective when using range
grading is to discriminate between classes instead of estimating an
exact value from a perceived symbol size. However, because human
perception of symbol size is limited, it is always recommended to
add a second perception channel to improve the discrimination
task. Colors from a sequential palette will complement symbol size to
encode the groups.

Two alternative are available to display the data: 

1. The =sp= package and the =spplot= function (based on =lattice= graphics).
2. The =ggplot2= package and the =geom_sf= function.

In both cases, the data is imported with the =sf= package and its
function =st_read=. This function returns an object of class =sf=.

#+INDEX: Packages!sf@\texttt{sf}
#+INDEX: Data!Air quality in Madrid

#+begin_src R
library("sf")

NO2sf <- st_read(dsn = "data/Spatial/", layer = "NO2sf")
#+end_src

* Proportional Symbol Mapping with =spplot=
#+begin_src R :exports none
##################################################################
## Proportional symbol with spplot
##################################################################
#+end_src

The =spplot= method provided by the =sp= package, based on =xyplot=
from the =lattice= package, is able to display
=SpatialPointsDataFrame= objects, among others classes. The =sf=
object returned by =st_read= has to be converted to a =Spatial= class.

#+INDEX: Packages!sp@\texttt{sp}
#+begin_src R
library("sp")

NO2sp <- as(NO2sf, "Spatial")
#+end_src

#+INDEX: Subjects!Sequential palette
A sequential palette is defined with =colorRampPalette=, with colors
denoting the value of the variable (green for lower values of the
contaminant, brown for intermediate values, and black for highest

#+begin_src R
airPal <- colorRampPalette(c("springgreen1", "sienna3", "gray5"))(5)
#+end_src

* Proportional Symbol Mapping with =ggplot2= and =spplot=
#+begin_src R :exports none
##################################################################
## Proportional symbol with ggplot2 and spplot
##################################################################
#+end_src

The =ggplot2= package is able to display spatial point observations
with the =geom_sf= function. This function understands the classes
defined by the =sf= package, that provides the function
=st_read= to read the data:

#+INDEX: Packages!sf@\texttt{sf}
#+INDEX: Data!Air quality in Madrid

#+begin_src R :eval no-export
library(sf)

NO2sf <- st_read(dsn = 'data', layer = 'NO2sp')
## Create a categorical variable
NO2sf$Mean <- cut(NO2sf$mean, 5)
#+end_src

Both color and size can be combined in a unique graphical output using =aes= and =scale_fill_manual=:  
#+begin_src R
ggplot(data = NO2sf) + 
    geom_sf(aes(size = Mean, fill = Mean),
            pch = 21, col = 'black') +
    scale_fill_manual(values = airPal) +
    theme_bw()
#+end_src

#+RESULTS:

The =spplot= method provided by the =sp= package, based on =xyplot=
from the =lattice= package, is able to display
=SpatialPointsDataFrame= objects, among others classes.

#+begin_src R
library(sp)

NO2sp <- as(NO2sf, "Spatial")
#+end_src

The arguments =col.regions= and =cex= in =spplot= are used for encoding color and size (Figure
ref:fig:airMadrid_spplot).

#+begin_src R :results output graphics file :exports both :file figs/Spatial/airMadrid_spplot.pdf  
spplot(NO2sp["mean"],
       col.regions = airPal, ## Palette
       cex = sqrt(1:5), ## Size of circles
       edge.col = "black", ## Color of border
       scales = list(draw = TRUE), ## Draw scales
       key.space = "right") ## Put legend on the right
#+end_src

#+CAPTION: Annual average of $NO_2$ measurements in Madrid. Values are shown with different symbol sizes and  colors for each class with the =spplot= function. label:fig:airMadrid_spplot
#+RESULTS:
[[file:figs/Spatial/airMadrid_spplot.pdf]]

* Proportional Symbol Mapping with =ggplot=
#+begin_src R :exports none
##################################################################
## Proportional symbol with ggplot
##################################################################
#+end_src

The =ggplot2= package is able to display spatial point observations
with the =geom_sf= function. No previous conversion is needed because
this function understands the =sf= class:

#+begin_src R
## Create a categorical variable
NO2sf$Mean <- cut(NO2sf$mean, 5)

ggplot(data = NO2sf) + 
    geom_sf(aes(size = Mean, fill = Mean),
            pch = 21, col = "black") +
    scale_fill_manual(values = airPal) +
    theme_bw()
#+end_src

#+RESULTS:

* Optimal Classification to Improve Discrimination
label:sec:classification_bubble
#+begin_src R :exports none
##################################################################
## Optimal classification and sizes to improve discrimination
##################################################################
#+end_src


Two main improvements can be added to Figure
ref:fig:airMadrid_spplot:

- Define classes dependent on the data structure (instead of the
  uniform distribution assumed with =cut=). A suitable approach is the
  =classInterval= function of the =classInt= package, which implements
  the Fisher-Jenks optimal classification algorithm[fn:5]. This
  classification method seeks to reduce the variance within classes
  and maximize the variance between classes.

#+INDEX: Packages!classInt@\texttt{classInt}
#+INDEX: Subjects!Class Intervals

#+begin_src R 
library("classInt")
## The number of classes is chosen between the Sturges and the
## Scott rules.
nClasses <- 5
intervals <- classIntervals(NO2sp$mean, n = nClasses, style = "fisher")
## Number of classes is not always the same as the proposed number
nClasses <- length(intervals$brks) - 1
#+end_src

#+begin_src R
op <- options(digits = 4)
tab <- print(intervals)
options(op)
#+end_src

- Encode each group with a symbol size (circle area) such that visual
  discrimination among classes is enhanced. The next code uses the set
  of radii proposed in cite:Dent.Torguson.ea2008 (Figure
  ref:fig:dent). This set of circle sizes is derived from studies by
  Meihoefer cite:Meihoefer1969. He derived a set of ten circle sizes
  that were easily and consistently discriminated by his subjects. The
  alternative proposed by Dent et al. improves the discrimination
  between some of the circles.

#+INDEX: Subjects!Visual discrimination

#+begin_src R 
## Complete Dent set of circle radii (mm)
dent <- c(0.64, 1.14, 1.65, 2.79, 4.32, 6.22, 9.65, 12.95, 15.11)
## Subset for our dataset
dentAQ <- dent[seq_len(nClasses)]
## Link Size and Class: findCols returns the class number of each
## point; cex is the vector of sizes for each data point
idx <- findCols(intervals)
cexNO2 <- dentAQ[idx]
#+end_src

#+begin_src R :exports results :tangle no :results output graphics file :width \\textwidth :file figs/Spatial/dent.pdf :eval no-export
xDent <- sqrt(cumsum(dent[1:7]))

xyplot(rep(1, 7) ~ xDent,
       cex = dent[1:7],
       scales = list(draw = FALSE),
       xlab = "", ylab = "",
       pch = 21, alpha = 0.6,
       fill = "midnightblue",
       col = "black",
       aspect = 1/6)
#+end_src


#+CAPTION: Symbol sizes proposed by Borden Dent. label:fig:dent
#+RESULTS[2d7b458986433b448eb743509896f8e7e8eb4e71]:
[[file:figs/Spatial/dent-crop.pdf]]

These two enhancements are included in Figure
ref:fig:airMadrid_classes, which displays the categorical variable
=classNO2= (instead of =mean=) whose levels are the intervals
previously computed with =classIntervals=. In addition, this figure
includes an improved legend.

#+begin_src R :results output graphics file :exports both :file figs/Spatial/airMadrid_classes.pdf
## spplot version
NO2sp$classNO2 <- factor(names(tab)[idx])  

## Definition of an improved key with title and background
NO2key <- list(x = 0.99, y = 0.01, corner = c(1, 0),
               title = expression(NO[2]~~(paste(mu, plain(g))/m^3)),
               cex.title = 0.8, cex = 1,
               background = "gray92")

pNO2 <- spplot(NO2sp["classNO2"],
               col.regions = airPal,
               cex = dentAQ * 0.8,
               edge.col = "black",
               scales = list(draw = TRUE),
               key.space = NO2key)
pNO2
#+end_src 

#+CAPTION: Annual average of $NO_2$ measurements in Madrid. Enhancement of Figure ref:fig:airMadrid_spplot, using symbol sizes proposed by Borden Dent and an improved legend. label:fig:airMadrid_classes
#+RESULTS[9f53f6015cd95a3fec85c3619d7aba384e1fa0f2]:
[[file:figs/Spatial/airMadrid_classes.pdf]]

The =ggplot= version uses the same categorical variable, added to the =NO2sf= object.
#+begin_src R
## ggplot2 version
NO2sf$classNO2 <- factor(names(tab)[idx])  

ggplot(data = NO2sf) +
    geom_sf(aes(size = classNO2, fill = classNO2),
            pch = 21, col = "black") +
    scale_fill_manual(values = airPal) +
    scale_size_manual(values = dentAQ * 2)  +
    xlab("") + ylab("") + theme_bw() 
    #+end_src
#+RESULTS:

* Spatial Context with Underlying Layers and Labels
#+begin_src R :exports none
##################################################################
## Spatial context with underlying layers and labels
##################################################################
#+end_src

#+RESULTS:

#+INDEX: Subjects!Background map

The spatial distribution of the stations is better understood if we
add underlying layers with information about the spatial context.

A common solution is to add an underlying layer with a static image
representing a map. Such image can be downloaded from a provider such
as Google Maps\textsuperscript{\texttrademark} or OpenStreetMap. There
are packages such as =ggmap= that provide an interface to these map
servers, providing raster images from static maps.

This approach faces two main problems: the user can neither modify
the image nor use its content to produce additional information; most
of the providers require registration and payments, and impose usage
restrictions due to copyright.

A different approach is to use digital vector data (points, lines, and
polygons) that can be filtered and transformed. I will illustrate this
approach with two different solutions: remote data obtained from the
OpenStreetMap project with the =osmdata= package; local data contained
in a shapefile (a format commonly used by public and private providers
to distribute information).

** OpenStreetMap with =osmdata=
label:sec:bubbles_osm
#+begin_src R :exports none
##################################################################
## OpenStreetMap
##################################################################
#+end_src

#+INDEX: Packages!osmdata@\textttt{osmdata}
The =osmdata= package is able to access the OpenStreepMap data with
queries defined with the functions =opq= and =add_osm_feature=. The
=opq= function defines the base query (region of interest in this
example), and the =add_osm_feature= filters the features to be
downloaded. The streets in a city can be retrieved with the key
"highway" (any kind of road, street or path) and the value
"residential"[fn:4].

#+begin_src R
library("osmdata")

madridBox <- st_bbox(NO2sf)

qosm <- opq(madridBox) %>%
  add_osm_feature(key = "highway",
                  value = "residential")
#+end_src

The =qosm= object is only the definition of the query. The data is
downloaded with a call to the functions =osmdata_sf= (=sf= objects)
and =osmdata_sp= (=Spatial*= objects).
#+begin_src R
qsf <- osmdata_sf(qosm)
#+end_src

The result includes points, lines and polygons. The next code displays
the =NO2sf= data using the street lines (=qsf$osm_lines=) as the
context, and a label for each station with the function
=geom_text_repel= of the =ggrepel= package (Figure
ref:fig:airMadrid_osm).

#+INDEX: Packages!ggrepel@\textttt{ggrepel}

#+begin_src R :results output graphics file :exports both :file figs/Spatial/airMadrid_osm.png :width 4000 :height 4000 :res 600
library(ggrepel)

ggplot()+
  ## Layers are drawn sequentially, so the NO2sf layer must be in
  ## the last place to be on top
  geom_sf(data = qsf$osm_lines["name"],
          size = 0.3,
          color = "lightgray") +
  geom_sf(data = NO2sf,
          aes(size = classNO2,
              fill = classNO2),
          pch = 21, col = "black") +
  ## Labels for each point, with position according to the circle size
  ## and the rest of labels
  geom_text_repel(data = NO2sf,
                  aes(label = substring(codEst, 7),
                      geometry = geometry,
                      point.size = classNO2),
                  stat = "sf_coordinates") + 
  scale_fill_manual(values = airPal) +
  scale_size_manual(values = dentAQ * 2) +
  labs(x = NULL, y = NULL) + theme_bw()
#+end_src

#+CAPTION: Annual average of $NO_2$ measurements in Madrid. Enhancement of Figure ref:fig:airMadrid_classes, displaying OpenStreepMap data in an underlying layer. label:fig:airMadrid_osm
#+RESULTS:
[[file:figs/Spatial/airMadrid_osm.png]]

The =spplot= version needs the data to be downloaded as =Spatial*=
objects with =osmdata_sp=.
#+begin_src R
qsp <- osmdata_sp(qosm)
#+end_src
The result can be combined with the =NO2sp= object with the
=sp.layout= argument of =spplot=, which accepts a call to a function
defined in a list.
#+begin_src R :exports none :results none
qspLines <- list("sp.lines", qsp$osm_lines["name"],
                 lwd = 0.1)

spplot(NO2sp["classNO2"],
       col.regions = airPal,
       cex = dentAQ,
       edge.col = "black",
       alpha = 0.8,
       sp.layout = qspLines,
       scales = list(draw = TRUE),
       key.space = NO2key)
#+end_src

** Shapefiles
#+begin_src R :exports none
##################################################################
## Shapefiles
##################################################################
#+end_src

#+INDEX: Data!Nomenclator Madrid
#+INDEX: Packages!sf@\texttt{sf}

The geographical information of Madrid is available at the "nomecalles" web service[fn:1]. The =data= folder contains compressed files with several shapefiles downloaded from this service. These shapefiles can be read with the =st_read= function from the =sf= package. 

#+begin_src R
## Madrid districts
unzip("data/Spatial/distr2022.zip", exdir = tempdir())

distritosMadridSF <- st_read(dsn = tempdir(),
                             layer = "dist2022")
## Filter the streets of the Municipality of Madrid
distritosMadridSF <- distritosMadridSF[distritosMadridSF$CMUN == "079",]
## Assign the geographical reference
distritosMadridSF <- st_transform(distritosMadridSF,
                                  crs = "WGS84")

## Madrid streets
unzip("data/Spatial/call2022.zip", exdir = tempdir())

streetsMadridSF <- st_read(dsn = tempdir(),
                           layer = "Gdie_g_calles")                           
streetsMadridSF <- streetsMadridSF[streetsMadridSF$CDMUNI == "079",]
streetsMadridSF <- st_transform(streetsMadridSF,
                                crs = "WGS84")
#+end_src

The =sf= objects produced with these code can be displayed together
with the =NO2sf= object with consecutive calls to =geom_sf=. Figure
ref:fig:airMadrid displays the final result.

#+begin_src R :results output graphics file :exports both :file figs/Spatial/airMadrid.png :width 4000 :height 4000 :res 600
ggplot()+
  geom_sf(data = streetsMadridSF,
          size = 0.1,
          color = "darkgray") +
  geom_sf(data = distritosMadridSF,
          fill = "lightgray",
          alpha = 0.2,
          size = 0.15,
          color = "black") +
  geom_sf(data = NO2sf,
          aes(size = classNO2,
              fill = classNO2),
          pch = 21, col = "black") + 
  geom_text_repel(data = NO2sf,
                  aes(label = substring(codEst, 7),
                      geometry = geometry,
                      point.size = classNO2),
                  size = 2.5,
                  stat = "sf_coordinates") + 
  scale_fill_manual(values = airPal) +
  scale_size_manual(values = dentAQ * 2) +
  labs(x = NULL, y = NULL) + theme_bw()
#+end_src

#+CAPTION: Annual average of $NO_2$ measurements in Madrid using shapefiles (lines and polygons) and text as geographical context. label:fig:airMadrid
#+RESULTS:
[[file:figs/Spatial/airMadrid.png]]




These shapefiles can also be used with =spplot= (after a class
conversion) thanks to the =sp.layout= argument of this function or
with the =layer= and =+.trellis= functions from the =latticeExtra=
package.

#+begin_src R
distritosMadridSP <- as(distritosMadridSF, "Spatial")
streetsMadridSP <- as(streetsMadridSF, "Spatial")
## Lists using the structure accepted by sp.layout, with the polygons,
## lines, and points, and their graphical parameters
spDistricts <- list("sp.polygons", distritosMadridSP,
                    fill = "gray97", lwd = 0.3)
spStreets <- list("sp.lines", streetsMadridSP,
                  lwd = 0.05)
#+end_src

#+begin_src R :eval no-export
## spplot with sp.layout version
spplot(NO2sp["classNO2"],
       col.regions = airPal,
       cex = dentAQ,
       edge.col = "black",
       alpha = 0.8,
       sp.layout = list(spDistricts, spStreets),
       scales = list(draw = TRUE),
       key.space = NO2key)
#+end_src

#+begin_src R :exports none :results none
## lattice with layer version
pNO2 +
    ## Polygons and lines *below* (layer_) the figure
    layer_(
    {
        sp.polygons(distritosMadridSP,
                    fill = "gray97",
                    lwd = 0.3)
        sp.lines(streetsMadridSP,
                 lwd = 0.05)
    })
#+end_src

* Spatial Interpolation
#+begin_src R :exports none
##################################################################
## Spatial interpolation
##################################################################
#+end_src
The measurements at discrete points give limited information about the
underlying process. It is quite common to approximate the spatial
distribution of the measured variable with the interpolation between
measurement locations. Selection of the optimal interpolation method
is outside the scope of this book. The interested reader is referred
to cite:Cressie.Wikle2015 and cite:Bivand.Pebesma.ea2013.

The following code illustrates an easy solution using inverse distance
weighted (IDW) interpolation with the =gstat= package cite:Pebesma2004
/only/ for illustration purposes.
 
#+INDEX: Packages!gstat@\texttt{gstat}
\nomenclature{IDW}{Inverse Distance Weighted interpolation.}

#+begin_src R
library("gstat")

## Sample 10^5 points locations within the bounding box of NO2sp using
## regular sampling
airGrid <- spsample(NO2sp, type = "regular", n = 1e5)
## Convert the SpatialPoints object into a SpatialGrid object
gridded(airGrid) <- TRUE
## Compute the IDW interpolation
airKrige <- krige(mean ~ 1, NO2sp, airGrid)
#+end_src

The result is a =SpatialPixelsDataFrame= that can be displayed with
=spplot= and combined with the previous layers and the measurement
station points (Figure ref:fig:airMadrid_krige).

#+begin_src R :results output graphics file :exports both :file figs/Spatial/airMadrid_krige.png :width 4000 :height 4000 :res 600
spplot(airKrige["var1.pred"], ## Variable interpolated
       col.regions = colorRampPalette(airPal)) +
  layer({ ## Overlay boundaries and points
    sp.polygons(distritosMadridSP,
                fill = "transparent",
                lwd = 0.3)
    sp.lines(streetsMadridSP,
             lwd = 0.07)
    sp.points(NO2sp,
              pch = 21,
              alpha = 0.8,
              fill = "gray50",
              col = "black")
  })
#+end_src

#+CAPTION: Kriging annual average of $NO_2$ measurements in Madrid. label:fig:airMadrid_krige
#+RESULTS:
[[file:figs/Spatial/airMadrid_krige.png]]


* Interactive Graphics
label:sec:interactive_bubble
#+begin_src R :exports none
##################################################################
## Interactive graphics
##################################################################
#+end_src

#+INDEX: Subjects!Interactive visualization

Now, let's suppose you need to know the median and standard deviation
of the time series of a certain station. Moreover, you would like to
view the photography of that station; or even better, you wish to
visit its webpage for additional information. A frequent solution is
to produce interactive graphics with tooltips and hyperlinks.

In this section we visit several approaches to create these products:
the =mapview= package based on the =htmlwidgets= package; export to
GeoJSON and KML formats; and 3D visualization with the =rgl= package.

\nomenclature{GeoJSON}{Format for encoding a variety of geographic data structures.}
\nomenclature{KML}{Keyhole Markup Language, an XML notation for expressing geographic annotation and visualization within Internet-based, two-dimensional maps and three-dimensional Earth browsers.}

** mapview 
label:sec:mapview_bubble

#+begin_src R :exports none
##################################################################
## mapView
##################################################################
#+end_src

The syntax of =mapview=[fn:12] resembles the syntax of =spplot=. Its
first argument is the spatial object with the information and the
variable to be depicted is selected with the argument
=zcol=. Moreover, the size of the points can be linked to another
variable with the argument =cex=, and their labels extracted from
another variable with the argument =label=.

The next code produces an HTML page with an interactive graphic
inserted in it (Figure ref:fig:mapview_bubble_simple). When the mouse
is hovered over a point its label is displayed, and if the point is
selected a tooltip with the whole information is deployed.

#+INDEX: Packages!mapview@\texttt{mapview}
#+INDEX: Subjects!Tooltip

#+begin_src R
library("mapview")

pal <- colorRampPalette(c("springgreen1", "sienna3", "gray5"))

mapview(NO2sp,
        zcol = "mean", ## Variable to display
        cex = "mean", ## Use this variable for the circle sizes
        col.regions = pal,
        label = NO2sp$Nombre,
        legend = TRUE)

#+end_src

#+CAPTION: Snapshot of the interactive graphic produced with =mapview= depicting the annual average of $NO_2$ measurements in Madrid. label:fig:mapview_bubble_simple
[[file:figs/Spatial/mapview_simple.png]]

*** Tooltips with images and graphs
#+begin_src R :exports none
##################################################################
## Tooltips with images and graphs
##################################################################
#+end_src

The tooltip included in the previous graphic is very simple: only text
displaying a table with information. This tooltip can be improved
thanks to the =popup= argument and the =popup*= family of
functions. For example, the next code creates an interactive graphic
whose tooltips show an image of the station (available in the =images=
folder of the repository[fn:10]) using the =popupImage= function (Figure
ref:fig:mapview_popup_images).

As an additional feature, the provider[fn:11] of the background map is
selected with the argument =map.type=.

#+INDEX: Subjects!Tooltip
#+INDEX: Subjects!Background map

#+begin_src R
library("leafpop")

img <- paste("images/Spatial/", NO2sp$codEst, ".jpg", sep = "")

mapview(NO2sp,
        zcol = "mean",
        cex = "mean",
        col.regions = pal, 
        label = NO2sp$Nombre,
        popup = popupImage(img, src = "local", embed = TRUE),
        map.type = "Esri.WorldImagery",
        legend = TRUE)
#+end_src

#+CAPTION: Snapshot of the interactive graphic produced with =mapview= with tooltips including images. label:fig:mapview_popup_images
[[file:figs/Spatial/mapview_popup_images.png]]


A more sophisticated solution displays a scatterplot when a tooltip is
deployed. The =popupGraph= function accepts a list of graphics and
selects the one corresponding to the location selected by the
user. This list is produced with the next code: first, the
measurements time series is read and filtered; second, the stations
code is extracted; finally, a loop with =lapply= creates a time series
graphic for each station displaying the evolution of the measurements
along the time period.

#+begin_src R
## Read the time series
airQuality <- read.csv2("data/Spatial/airQuality.csv")
## We need only NO2 data (codParam 8)
NO2 <- subset(airQuality, codParam == 8)
## Time index in a new column
NO2$tt <- with(NO2,
               as.Date(paste(year, month, day, sep = "-")))
## Stations code
stations <- unique(NO2$codEst)
## Loop to create a scatterplot for each station.
pList <- lapply(stations,
                function(i)
                    xyplot(dat ~ tt, data = NO2,
                           subset = (codEst == i),
                           type = "l",
                           xlab = "", ylab = "")
                )
#+end_src

This list of graphics, =pList=, is provided to =mapview= through the
=popup= argument with the function =popupGraph= (Figure ref:fig:mapview_popup_graphs).

#+INDEX: Subjects!Tooltip

#+begin_src R
mapview(NO2sp,
        zcol = "mean",
        cex = "mean",
        col.regions = pal, 
        label = NO2sp$Nombre,
        popup = popupGraph(pList),
        map.type = "Esri.WorldImagery",
        legend = TRUE)
#+end_src

#+CAPTION: Snapshot of the interactive graphic produced with =mapview= with tooltips including time series graphics. label:fig:mapview_popup_graphs
[[file:figs/Spatial/mapview_popup_graphs.png]]



*** Synchronise multiple graphics  
#+begin_src R :exports none
##################################################################
## Synchronise multiple graphics  
##################################################################
#+end_src

The =mapview= package recreates the small multiple technique (Sections
ref:SEC:sameScale and ref:SEC:groupVariable) with the functions =sync=
and =latticeView=. With them, multiple variables can be rendered
simultaneously and synchronised together (with the =sync= function):
- if a panel is zoomed, all other panels will also zoom
- the mouse position in a panel is signaled with a red circle in the
  rest of panels.

The next code generates three graphics to view different variables of
the =NO2sp= object using different values in =zcol= and =cex=. All of
them are viewed and synchronised together with =sync= (Figure
ref:fig:mapview_sync):

#+INDEX: Subjects!Background map

#+begin_src R
library("leafsync")

## Map of the average value
mapMean <- mapview(NO2sp, zcol = "mean", cex = "mean",
                   col.regions = pal, legend = TRUE,
                   map.types = "OpenStreetMap.Mapnik",
                   label = NO2sp$Nombre)

## Map of the median
mapMedian <- mapview(NO2sp, zcol = "median", cex = "median",
                     col.regions = pal, legend = TRUE,
                     #map.type = "NASAGIBS.ViirsEarthAtNight",
                     label = NO2sp$Nombre)

## Map of the standard deviation
mapSD <- mapview(NO2sp, zcol = "sd", cex = "sd",
                 col.regions = pal, legend = TRUE,
                 map.type = "Esri.WorldImagery",
                 label = NO2sp$Nombre)

## All together
sync(mapMean, mapMedian, mapSD, ncol = 3)
#+end_src

#+CAPTION: Snapshot of multiple interactive graphics produced with =mapview=. label:fig:mapview_sync
[[file:figs/Spatial/mapview_sync.png]]


** Export to Other Formats

A different approach is to use an external data viewer, due to its
features or its large community of users. Two tools deserve to be
mentioned: GeoJSON rendered within GitHub repositories, and Keyhole
Markup Language (KML) files imported in Google Earth\texttrademark.

*** GeoJSON and OpenStreetMap
#+begin_src R :exports none
##################################################################
## GeoJSON and OpenStreepMap
##################################################################
#+end_src
GeoJSON is an open computer file format for encoding collections of
simple geographical features along with their nonspatial attributes
using JavaScript Object Notation (JSON). The =sf= package can produce
GeoJSON files with the =st_write= function.
#+INDEX: Packages!sf@\texttt{sf}
#+INDEX: Subjects!GeoJSON
#+INDEX: Subjects!KML

#+begin_src R :eval no-export
st_write(NO2sf,
         dsn = "data/Spatial/NO2.geojson",
         layer = "NO2sp",
         driver = "GeoJSON")
#+end_src

Figure ref:fig:geojson shows a snapshot of the rendering of this
GeoJSON file using the geojson.io[fn:2] service. You can zoom on the
map and click on the stations to display the data.

#+CAPTION: label:fig:geojson $NO_2$ data in a GeoJSON file rendered with the geojson.io service.
file:figs/Spatial/geojson.png


*** Keyhole Markup Language
#+begin_src R :exports none
##################################################################
## Keyhole Markup Language
##################################################################
#+end_src

Keyhole Markup Language (KML) is a file format to display geographic
data within Internet-based, two-dimensional maps and three-dimensional
Earth browsers. KML uses a tag-based structure with nested elements
and attributes, and is based on the XML standard. KML became an
international standard of the Open Geospatial Consortium
in 2008. Google Earth was the first program able to view and
graphically edit KML files, although Marble, an open-source project,
also offers KML support.

#+INDEX: Packages!sf@\texttt{sf}
#+INDEX: Subjects!KML

There are several packages able to generate KML files. For example,
the =st_write= function from the =sf= package can also write KML
files:

#+begin_src R :eval no-export
st_write(NO2sf,
         dsn = "data/Spatial/NO2_mean.kml",
         layer = "mean",
         driver = "KML")
#+end_src

This file that can be directly opened with Google Earth or Marble.

** 3D visualization
#+begin_src R :exports none
##################################################################
## 3D visualization
##################################################################
#+end_src

#+INDEX: Packages!rgl@\texttt{rgl}
#+INDEX: Subjects!3D visualization
#+INDEX: Subjects!WebGL

An alternative method is 3D visualization where the user can rotate or
zoom the figure. This solution is available thanks to the =rgl=
package, which provides functions for 3D interactive graphics.

#+begin_src R
library("rgl")
#+end_src

Previously, the =SpatialPointsDataFrame= object must be converted to a
=data.frame=. The =xyz= coordinates will be the longitude, latitude,
and altitude of each station.

#+begin_src R
## rgl does not understand Spatial* objects
NO2df <- as.data.frame(NO2sp)
#+end_src

The color of each point is determined by the corresponding class
(Section ref:sec:classification_bubble), and the radius of each bubble
depends on the mean value of the depicted variable.

#+begin_src R
## Color of each point according to its class
airPal <- colorRampPalette(c("springgreen1", "sienna3", "gray5"))(5)
colorClasses <- airPal[NO2df$classNO2]
#+end_src

A snapshot of this graphic is displayed in Figure
ref:fig:rgl_bubble.

#+begin_src R
plot3d(x = NO2df$coords.x1, 
       y = NO2df$coords.x2,
       z = NO2df$alt, 
       xlab = "Longitude", 
       ylab = "Latitude", 
       zlab = "Altitude", 
       type = "s", 
       col = colorClasses,
       radius = NO2df$mean/10)
#+end_src

#+CAPTION: Snapshot of the interactive graphic produced with =rgl=. label:fig:rgl_bubble
[[file:figs/Spatial/rgl_bubble.png]]


* Footnotes
[fn:10]These images have been obtained from the Air Quality portal of Madrid, https://airedemadrid.madrid.es/, following the path "Actuaciones municipales > Sistema integral de calidad del aire > Vigilancia".

[fn:4] More details available in https://wiki.openstreetmap.org/wiki/Key:highway.  
[fn:2] https://geojson.io/ 

[fn:12] The package =mapview= is able to work both with =sp= and =sf= objects. In this section the code works with =sp= objects, but would work without modification with =sf= objects.

[fn:11] The list of provider is available in http://leaflet-extras.github.io/leaflet-providers/preview/

[fn:9] Do not confuse a =raster= object with the =Raster*= objects of the =raster= package.

[fn:7] [[https://epsg.io/3857]]

[fn:5] This classification method will be used in section ref:sec:quantitative_choropleth with a choropleth map.

[fn:1] https://gestiona.comunidad.madrid/nomecalles_web/

[fn:8] [[http://jquery.com/]]

[fn:6] [[http://jqueryui.com/]]

[fn:3] [[http://www.openstreetmap.org/]]
