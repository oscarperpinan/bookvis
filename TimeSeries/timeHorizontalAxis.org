#+PROPERTY:  header-args :session *R* :tangle ../docs/R/timeHorizontalAxis.R :eval no-export
#+OPTIONS: ^:nil
#+BIND: org-export-latex-image-default-option "height=0.45\\textheight"

#+begin_src R :exports none :tangle no
Sys.setlocale("LC_TIME", 'C')

setwd('~/github/bookvis')
#+end_src

#+begin_src R :exports none  
##################################################################
## Initial configuration
##################################################################
## Clone or download the repository and set the working directory
## with setwd to the folder where the repository is located.
 
library(lattice)
library(ggplot2)
## latticeExtra must be loaded after ggplot2 to prevent masking of its
## `layer` function.
library(latticeExtra)

source('configLattice.R')
##################################################################
#+end_src

#+RESULTS:


* Time Graph of Variables with Different Scales  label:sec:differentVariables
#+begin_src R :exports none
##################################################################
## Time graph of variables with different scales
##################################################################
#+end_src
There is a variety of scientific research interested in the
relationship among several meteorological variables. A suitable
approach is to display the time evolution of all of them using a
panel for each of the variables. The superposition of variables
with different characteristics is not very useful (unless their
values were previously rescaled), so this option is postponed for
Section ref:SEC:sameScale.

For this example we will use the eight years of daily data from the
SIAR meteorological station located at Aranjuez (Madrid).  This
multivariate time series can be displayed with the =xyplot= method of
=lattice= for =zoo= objects with a panel for each variable (Figure
[[ref:fig:aranjuezNaive]]).

#+INDEX: Packages!zoo@\texttt{zoo}
#+INDEX: Data!SIAR
#+INDEX: Data!Meteorological variables

#+begin_src R
library(zoo)
load('data/aranjuez.RData')
#+end_src

#+RESULTS:
: aranjuez

#+begin_src R :results output graphics :exports both :file figs/aranjuez.pdf
## The layout argument arranges panels in rows
xyplot(aranjuez, layout = c(1, ncol(aranjuez)))
#+end_src


#+CAPTION: Time plot of the collection of meteorological time series of the Aranjuez station (=lattice= version). label:fig:aranjuezNaive 
#+RESULTS:
[[file:figs/aranjuez.pdf]]

The package =ggplot2= provides the generic method =autoplot= to
automate the display of certain classes with a simple command. The
package =zoo= provides an =autoplot= method for the =zoo= class with a
result similar to that obtained with =xyplot= (Figure [[ref:fig:aranjuezNaiveGG]])

#+begin_src R :results output graphics :exports both :file figs/aranjuezGG.pdf
autoplot(aranjuez) + facet_free()
#+end_src

#+CAPTION: Time plot of the collection of meteorological time series of the Aranjuez station (=ggplot2= version). label:fig:aranjuezNaiveGG 
#+RESULTS:
[[file:figs/aranjuezGG.pdf]]


** \floweroneleft Annotations to Enhance the Time Graph

#+begin_src R :exports none
##################################################################
## Annotations to enhance the time graph
##################################################################
#+end_src

These first attempts can be improved with a custom panel function
that generates the content of each panel using the information
processed by =xyplot=, or overlaying additional layers with
=autoplot=.  One of the main enhancements is to highlight certain time
regions that fulfill certain conditions. The package =latticeExtra=
provides a nice solution for =xyplot= with =panel.xblocks=. The result
is displayed in Figure ref:fig:aranjuezEnhanced:
 
- The alternating of years is displayed with blocks of gray and white
  color using the =panel.xblocks= function from =latticeExtra= (line
  [[(xblockYear)]]). The year is extracted (as character) from the time
  index of the =zoo= object with =format.POSIXlt= (line
  [[(yearFunction)]]).
- Those values below the mean of each variable are highlighted with
  short red color blocks at the bottom of each panel, again with the
  =panel.xblocks= function (line [[(xblockUnder)]]).
- The label of each time series is displayed with text inside each
  panel instead of using the strips mechanism. The =panel.text= prints
  the name of each variable with the aid of =panel.number= (line
  [[(text)]]).
- The maxima and minima are highlighted with small blue triangles
  (lines [[(maxTriangles)]] and [[(minTriangles)]] respectively).

Because the functions included in the panel function are executed
consecutively, their order determines the superposition of graphical
layers.

#+INDEX: Subjects!Panel function

#+begin_src R :exports none
## lattice version
#+end_src

#+begin_src R -n -r :results output graphics :exports both :file figs/aranjuezXblocks.pdf
## Auxiliary function to extract the year value of a POSIXct time
## index
Year <- function(x)format(x, "%Y")                           (ref:yearFunction)
  
xyplot(aranjuez,
       layout = c(1, ncol(aranjuez)),
       strip = FALSE,
       scales = list(y = list(cex = 0.6, rot = 0)),
       panel = function(x, y, ...){
           ## Alternation of years
           panel.xblocks(x, Year,                              (ref:xblockYear)
                         col = c("lightgray", "white"),
                         border = "darkgray")
           ## Values under the average highlighted with red regions
           panel.xblocks(x, y < mean(y, na.rm = TRUE),        (ref:xblockUnder)
                         col = "indianred1",
                         height = unit(0.1, 'npc'))
           ## Time series
           panel.lines(x, y, col = 'royalblue4', lwd = 0.5, ...)
           ## Label of each time series
           panel.text(x[1], min(y, na.rm = TRUE),                    (ref:text)
                      names(aranjuez)[panel.number()],
                      cex = 0.6, adj = c(0, 0), srt = 90, ...)
           ## Triangles to point the maxima and minima          
           idxMax <- which.max(y)                              (ref:maxTriangles)
           panel.points(x[idxMax], y[idxMax],
                        col = 'black', fill = 'lightblue', pch = 24)
           idxMin <- which.min(y)                            (ref:minTriangles)
           panel.points(x[idxMin], y[idxMin],
                        col = 'black', fill = 'lightblue', pch = 25)
       })
#+end_src

#+CAPTION: Enhanced time plot of the collection of meteorological time series of the Aranjuez station. label:fig:aranjuezEnhanced 
#+RESULTS:
[[file:figs/aranjuezXblocks.pdf]]

#+begin_src R :exports none
## ggplot2 version
#+end_src

There is no equivalent =panel.xblocks= function that can be used with
=ggplot2=. Therefore, the =ggplot2= version must explicitly compute
the corresponding bands (years and regions below the average values):

- The first step in working with =ggplot= is to transform the =zoo=
  object into a =data.frame= in long format. =fortify= returns a
  =data.frame= with three columns: the time =Index=, a factor
  indicating the =Series=, and the corresponding =Value=.

#+begin_src R :results output :exports both
timeIdx <- index(aranjuez)
  
aranjuezLong <- fortify(aranjuez, melt = TRUE)

summary(aranjuezLong)
#+end_src

#+RESULTS:
:      Index                 Series          Value       
:  Min.   :2004-01-01   TempAvg : 2898   Min.   :-12.98  
:  1st Qu.:2005-12-29   TempMax : 2898   1st Qu.:  2.01  
:  Median :2008-01-09   TempMin : 2898   Median :  8.62  
:  Mean   :2008-01-03   HumidAvg: 2898   Mean   : 22.05  
:  3rd Qu.:2010-01-03   HumidMax: 2898   3rd Qu.: 27.62  
:  Max.   :2011-12-31   WindAvg : 2898   Max.   :100.00  
:                       (Other) :11592   NA's   :37

- The bands of values below the average can be easily extracted with
  =scale= because these regions are negative when the =data.frame= is
  centered.

#+begin_src R
## Values below mean are negative after being centered
scaled <- fortify(scale(aranjuez, scale = FALSE), melt = TRUE)
## The 'scaled' column is the result of the centering.
## The new 'Value' column store the original values.
scaled <- transform(scaled, scaled = Value,
                    Value = aranjuezLong$Value)
underIdx <- which(scaled$scaled <= 0)
## 'under' is the subset of values below the average
under <- scaled[underIdx,]
#+end_src

#+RESULTS:

- The years bands are defined with the function =endpoints= from the
  =xts= package:

#+INDEX: Packages!xts@\texttt{xts}

#+begin_src R
library(xts)
ep <- endpoints(timeIdx, on = 'years')
ep <- ep[-1]
N <- length(ep)
## 'tsp' is start and 'tep' is the end of each band. One of each two
## years are selected.
tep <- timeIdx[ep[seq(1, N, 2)] + 1]
tsp <- timeIdx[ep[seq(2, N, 2)]]
#+end_src

- The minima and maxima points of each variable are extracted with
  =apply=:
#+begin_src R
minIdx <- timeIdx[apply(aranjuez, 2, which.min)]
minVals <- apply(aranjuez, 2, min, na.rm = TRUE)
mins <- data.frame(Index = minIdx,
                   Value = minVals,
                   Series = names(aranjuez))

maxIdx <- timeIdx[apply(aranjuez, 2, which.max)]
maxVals <- apply(aranjuez, 2, max, na.rm = TRUE)
maxs <- data.frame(Index = maxIdx,
                   Value = maxVals,
                   Series = names(aranjuez))
#+end_src

- With =ggplot= we define the canvas, and the layers of information are
  added successively:
#+begin_src R
ggplot(data = aranjuezLong, aes(Index, Value)) +
    ## Time series of each variable
    geom_line(colour = "royalblue4", lwd = 0.5) +
    ## Year bands
    annotate('rect',
             xmin = tsp, xmax = tep,
             ymin = -Inf, ymax = Inf,
              alpha = 0.4) + 
    ## Values below average
    geom_rug(data = under,
             sides = 'b', col = 'indianred1') +
    ## Minima
    geom_point(data = mins, pch = 25) +
    ## Maxima
    geom_point(data = maxs, pch = 24) +
    ## Axis labels and theme definition
    labs(x = 'Time', y = NULL) +
    theme_bw() +
    ## Each series is displayed in a different panel with an
    ## independent y scale
    facet_free()
#+end_src

Some messages from Figure ref:fig:aranjuezEnhanced:
- The radiation, temperature, and evotranspiration are
  quasi-periodic and are almost synchronized between them. Their
  local maxima appear in the summer and the local minima in the
  winter. Obviously, the summer values are higher than the
  average.
- The average humidity varies in oposition to the temperature and
  radiation cycle, with local maxima located during winter.
- The average and maximum wind speed, and rainfall vary in a more
  erratic way and do not show the evident periodic behavior of
  the radiation and temperature.
- The rainfall is different from year to year. The remaining variables
  do not show variations between years.
- The fluctuations of solar radiation are more apparent than
  the temperature fluctuations. There is hardly any day with
  temperatures below the average value during summer, while it is
  not difficult to find days with radiation below the average
  during this season.
  
* Time Series of Variables with the Same Scale label:SEC:sameScale
#+begin_src R :exports none
##################################################################
## Time series of variables with the same scale
##################################################################
#+end_src

As an example of time series of variables with the same scale, we will
use measurements of solar radiation from different meteorological
stations.

The first attempt to display this multivariate time series makes use
of the =xyplot.zoo= method. The objective of this graphic is to
display the behavior of the collection as a whole: the series are
superposed in the same panel (=superpose=TRUE=) without legend
(=auto.key=FALSE=), using thin lines and partial
transparency[fn:3]. Transparency softens overplotting problems and reveals
density clusters because regions with more overlapping lines are
darker. Figure ref:fig:navarraNaive displays the variations
around the time average (=avRad=).

#+INDEX: Data!Meteorological variables
#+INDEX: Data!Solar radiation

#+begin_src R
load('data/navarra.RData')
#+end_src

#+begin_src R :results output graphics :exports both :file figs/navarra.pdf
avRad <- zoo(rowMeans(navarra, na.rm = 1), index(navarra))
pNavarra <- xyplot(navarra - avRad,
                   superpose = TRUE, auto.key = FALSE,
                   lwd = 0.5, alpha = 0.3, col = 'midnightblue') 
pNavarra
#+end_src

#+CAPTION: Time plot of the variations around time average of solar radiation measurements from the meteorological stations of Navarra. label:fig:navarraNaive
#+RESULTS:
[[file:figs/navarra.pdf]]

This result can be improved with different methods: the cut-and-stack
method, and the horizon graph with =horizonplot=.

** Aspect Ratio and Rate of Change
#+begin_src R :exports none
##################################################################
## Aspect ratio and rate of change
##################################################################
#+end_src

When a graphic is intended to inform about the rate of change, special
attention must be paid to the aspect ratio of the graph, defined as
the ratio of the height to the width of the graphical
window. Cleveland analyzed the importance of the aspect ratio for
judging rate of change cite:Cleveland.McGill1984. He concluded that we
visually decode the information about the relative local rate of
change of one variable with another by comparing the orientations of
the local line segments that compose the polylines. The recommendation
is to choose the aspect ratio so that the absolute values of the
orientations of the segments are centered on $\SI{45}{\degree}$
(banking to $\SI{45}{\degree}$).

#+INDEX: Subjects!Aspect ratio

The problem with banking to $\SI{45}{\degree}$ is that the resulting
aspect ratio is frequently too small. A suitable solution to
minimize wasted space is the cut-and-stack method. The =xyplot.ts=
method implements this solution with the combination of the
arguments =aspect= and =cut=. The version of Figure
ref:fig:navarraNaive using banking to $\SI{45}{\degree}$ and the
cut-and-stack method is produced with (Figure ref:fig:navarraBanking):

#+begin_src R :results output graphics :exports both :file figs/navarraBanking.pdf
xyplot(navarra - avRad,
       aspect = 'xy', cut = list(n = 3, overlap = 0.1),
       strip = FALSE,
       superpose = TRUE, auto.key = FALSE,
       lwd = 0.5, alpha = 0.3, col = 'midnightblue')
#+end_src

#+CAPTION: Cut-and-stack plot with banking to $\SI{45}{\degree}$. label:fig:navarraBanking
#+RESULTS:
[[file:figs/navarraBanking.pdf]]

** The Horizon Graph label:sec:horizonplot
#+begin_src R :exports none
##################################################################
## The horizon graph
##################################################################
#+end_src

#+INDEX: Subjects!Horizon graph

The horizon graph is useful in examining how a large number of series
changes over time, and does so in a way that allows both comparisons
between the individual time series and independent analysis of
each series. Moreover, extraordinary behaviors and predominant
patterns are easily distinguished cite:Heer.Kong.ea2009,Few2008.

#+INDEX: Subjects!Diverging palette

This graph displays several stacked series collapsing the y-axis
to free vertical space:
- Positive and negative values share the same vertical
  space. Negative values are inverted and placed above the
  reference line. Sign is encoded using different hues (positive
  values in blue and negative values in red).
- Differences in magnitude are displayed as differences in color
  intensity (darker colors for greater differences).
- The color bands share the same baseline and are superposed, with
  darker bands in front of the lighter ones.

Because the panels share the same design structure, once this
technique is understood, it is easy to establish comparisons or spot
extraordinary events.  This method is what Tufte described as small
multiples cite:Tufte1990.

#+INDEX: Subjects!Small multiples

Figure ref:fig:navarraHorizonplot displays the variations of solar
radiation around the time average with an horizon graph using a row
for each time series. In the code we choose =origin=0= and leave the
argument =horizonscale= undefined (default). With this combination
each panel has different scales and the colors in each panel represent
deviations from the origin. This is depicted in the color key with the
$\Delta_i$ symbol, where the subscript =i= denotes the existence of
multiple panels with different scales.

#+INDEX: Packages!latticeExtra@\texttt{latticeExtra}

#+begin_src R :results output graphics :exports both :file figs/navarraHorizonplot.pdf
library(latticeExtra)
  
horizonplot(navarra - avRad,
            layout = c(1, ncol(navarra)),
            origin = 0, ## Deviations in each panel are calculated
                        ## from this value
            colorkey = TRUE, 
	    col.regions = brewer.pal(6, "RdBu"))
#+end_src

#+CAPTION: Horizon plot of variations around time average of solar radiation measurements from the meteorological stations of Navarra. The $\Delta_i$ symbol in the color key represents the deviation in each panel from the origin value. label:fig:navarraHorizonplot
#+RESULTS:
[[file:figs/navarraHorizonplot.pdf]]

Figure ref:fig:navarraHorizonplot allows several questions to be
answered:
- Which stations consistently measure above and below the average?
- Which stations resemble more closely the average time series?
- Which stations show erratic and uniform behavior?
- In each of the stations, is there any day with extraordinary measurements?
- Which part of the year is associated with more intense
  absolute fluctuations across the set of stations?

** Time Graph of the Differences between a Time Series and a Reference label:sec:differences

#+begin_src R :exports none
##################################################################
## Time graph of the differences between a time series and a reference
##################################################################
#+end_src

The horizon graph is also useful in revealing the differences between
a univariate time series and another reference. For example, we
might be interested in the departure of the observed temperature
from the long-term average, or in other words, the temperature
change over time.

Let's illustrate this approach with the time series of daily
average temperatures measured at the meteorological station of
Aranjuez. The reference is the long-term daily average calculated
with =ave=.

#+begin_src R 
Ta <- aranjuez$TempAvg
timeIndex <- index(aranjuez)
longTa <- ave(Ta, format(timeIndex, '%j'))
diffTa <- (Ta - longTa)
#+end_src

#+RESULTS:


The temperature time series, the long-term average and the
differences between them can be displayed with the =xyplot=
method, now using =screens= to use a different panel for the
differences time series (Figure ref:fig:diffTa_xyplot)
#+begin_src R :results output graphics :exports both :file figs/diffTa_xyplot.pdf
xyplot(cbind(Ta, longTa, diffTa),
       col = c('darkgray', 'red', 'midnightblue'),
       superpose = TRUE, auto.key = list(space = 'right'),
       screens = c(rep('Average Temperature', 2), 'Differences'))
#+end_src

#+CAPTION: Daily temperature time series, its long-term average and the differences between them. label:fig:diffTa_xyplot
#+RESULTS:
[[file:figs/diffTa_xyplot.pdf]]

The horizon graph is better suited for displaying the differences. The
next code again uses the cut-and-stack method (Figure
ref:fig:navarraBanking) to distinguish between years. Figure
ref:fig:diffTa_horizon shows that 2004 started clearly above the
average while 2005 and 2009 did the contrary. Year 2007 was frequently
below the long-term average but 2011 was more similar to that
reference.
#+begin_src R :results output graphics :exports both :file figs/diffTa_horizon.pdf
years <- unique(format(timeIndex, '%Y'))
  
horizonplot(diffTa, cut = list(n = 8, overlap = 0),
            colorkey = TRUE,
            col.regions = brewer.pal(6, "RdBu"),
            layout = c(1, 8),
            scales = list(draw = FALSE, y = list(relation = 'same')),
            origin = 0, strip.left = FALSE) +
    layer(grid.text(years[panel.number()], x  =  0, y  =  0.1, 
                    gp = gpar(cex = 0.8),
                    just = "left"))
#+end_src

#+CAPTION: Horizon graph displaying differences between a daily temperature time series and its long-term average. label:fig:diffTa_horizon
#+RESULTS:
[[file:figs/diffTa_horizon.pdf]]

A different approach to display this information is to produce a level
plot displaying the time series using parts of its time index as
independent and conditioning variables[fn:5]. The following code
displays the differences with the day of month on the horizontal axis
and the year on the vertical axis, with a different panel for each
month number. Therefore, each cell of Figure ref:fig:diffTa_level
corresponds to a certain day of the time series. If you compare this
figure with the horizon plot, you will find the same previous findings
but revealed now in more detail. On the other hand, while the horizon
plot of Figure ref:fig:diffTa_horizon clearly displays the yearly
evolution, the combination of variables of the level plot focuses on
the comparison between years in a certain month.

#+INDEX: Subjects!Diverging palette

#+begin_src R 
year <- function(x)as.numeric(format(x, '%Y'))
day <- function(x)as.numeric(format(x, '%d'))
month <- function(x)as.numeric(format(x, '%m'))
#+end_src

#+RESULTS:

#+begin_src R :results output graphics :exports both :file figs/diffTa_levelplot.pdf
myTheme <- modifyList(custom.theme(region = brewer.pal(9, 'RdBu')),
                      list(
                          strip.background = list(col = 'gray'),
                          panel.background = list(col = 'gray')))

maxZ <- max(abs(diffTa))

levelplot(diffTa ~ day(timeIndex) * year(timeIndex) | factor(month(timeIndex)),
          at = pretty(c(-maxZ, maxZ), n = 8),
          colorkey = list(height = 0.3),
          layout = c(1, 12), strip = FALSE, strip.left = TRUE,
          xlab = 'Day', ylab = 'Month', 
          par.settings = myTheme)

#+end_src

#+CAPTION: Level plot of differences between a daily temperature time series and its long-term average. label:fig:diffTa_level
#+RESULTS:
[[file:figs/diffTa_levelplot.pdf]]

The =ggplot= version of the Figure  ref:fig:diffTa_level requires a =data.frame= with the day, year, and month arranged in different columns.
#+begin_src R
df <- data.frame(Vals = diffTa,
                 Day = day(timeIndex),
                 Year = year(timeIndex),
                 Month = month(timeIndex))
#+end_src

The values (=Vals= column of this =data.frame=) are displayed as a level plot thanks to the =geom_raster= function.
#+begin_src R :results output graphics :exports both :file figs/diffTa_ggplot.pdf
library(scales) 
## The packages scales is needed for the pretty_breaks function.

ggplot(data = df,
       aes(fill = Vals,
           x = Day,
           y = Year)) +
    facet_wrap(~ Month, ncol = 1, strip.position = 'left') +
    scale_y_continuous(breaks = pretty_breaks()) + 
    scale_fill_distiller(palette = 'RdBu', direction = 1) + 
    geom_raster() +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank())
#+end_src



* Stacked Graphs label:sec:stacked
#+begin_src R :exports none
##################################################################
## Stacked graphs
##################################################################
#+end_src

If the variables of a multivariate time series can be summed to
produce a meaningful global variable, they may be better displayed
with stacked graphs. For example, the information on unemployment in
the United States provides data of unemployed persons by industry and
class of workers, and can be summed to give a total unemployment time
series.

#+INDEX: Data!Unemployment in USA

#+begin_src R
load('data/unemployUSA.RData')
#+end_src

The time series of unemployment can be directly displayed
with the =xyplot.zoo= method (Figure ref:fig:unemployUSAxyplot).

#+begin_src R :results output graphics :exports both :file "figs/unemployUSAxyplot.pdf" 
xyplot(unemployUSA,
       superpose = TRUE,
       par.settings = custom.theme,
       auto.key = list(space = 'right'))
#+end_src

#+CAPTION: Time series of unemployment  with =xyplot= using the default panel function. label:fig:unemployUSAxyplot
#+RESULTS:
[[file:figs/unemployUSAxyplot.pdf]]

This graphical output is not very useful: the legend includes too many
items; the vertical scale is dominated by the largest series, with
several series buried in the lower part of the scale; the trend,
variations and structure of the total and individual contributions
cannot be deduced from this graph.

A partial improvement is to display the multivariate time series as a
set of stacked colored polygons to follow the macro/micro principle
proposed by Tufte cite:Tufte1990: Show a collection of individual
time series and also display their sum. A traditional stacked graph is
easily obtained with =geom_area= (Figure ref:fig:unemployUSAgeomArea):

#+INDEX: Subjects!Stacked graph

#+begin_src R :results output graphics :exports both :file "figs/unemployUSAgeomArea.pdf" 
library(scales) ## scale_x_yearmon needs scales::pretty_breaks
autoplot(unemployUSA, facets = NULL, geom = 'area') +
    geom_area(aes(fill = Series)) +
    scale_x_yearmon()  
#+end_src

#+CAPTION: Time series of unemployment with stacked areas using =geom_area=. label:fig:unemployUSAgeomArea
#+RESULTS:
[[file:figs/unemployUSAgeomArea.pdf]]

Traditional stacked graphs have their bottom on the x-axis which makes
the overall height at each point easy to estimate. On the other hand,
with this layout, individual layers may be difficult to
distinguish. The /ThemeRiver/ cite:Havre.Hetzler.ea2002 (also named
/streamgraph/ in cite:Byron.Wattenberg2008) provides an innovative
layout method in which layers are symmetrical around the x-axis at
their center. At a glance, the pattern of the global sum and
individual variables, their contribution to conform the global sum,
and the interrelation between variables can be perceived.

I have defined a panel and prepanel functions[fn:4] to implement a
ThemeRiver with =xyplot=. The result is displayed in Figure
ref:fig:unemployUSAThemeRiver with a vertical line to indicate
one of main milestones of the financial crisis, whose effect on
the overall unemployment results is clearly evident.
#+NAME: panelFlow
#+begin_src R :exports none
panel.flow <- function(x, y, groups, origin, ...)
{
    dat <- data.frame(x = x, y = y, groups = groups)            (ref:dataframe)
    nVars <- nlevels(groups)
    groupLevels <- levels(groups)
    
    ## From long to wide
    yWide <- unstack(dat, y~groups)                               (ref:yunstack)
    ## Where are the maxima of each variable located? We will use
    ## them to position labels.
    idxMaxes <- apply(yWide, 2, which.max)
    
    ##Origin calculated following Havr.eHetzler.ea2002
    if (origin=='themeRiver') origin =  -1/2*rowSums(yWide)
    else origin = 0 
    yWide <- cbind(origin = origin, yWide)
    ## Cumulative sums to define the polygon
    yCumSum <- t(apply(yWide, 1, cumsum))                         (ref:ycumsum)
    Y <- as.data.frame(sapply(seq_len(nVars),                    (ref:yPolygon)
                              function(iCol)c(yCumSum[,iCol+1],
                                              rev(yCumSum[,iCol]))))
    names(Y) <- levels(groups)
    ## Back to long format, since xyplot works that way
    y <- stack(Y)$values                                           (ref:yStack)
    
    ## Similar but easier for x
    xWide <- unstack(dat, x~groups)                              (ref:xunstack)
    x <- rep(c(xWide[,1], rev(xWide[,1])), nVars)                (ref:xPolygon)
    ## Groups repeated twice (upper and lower limits of the polygon)
    groups <- rep(groups, each = 2)                                (ref:groups)
    
    ## Graphical parameters
    superpose.polygon <- trellis.par.get("superpose.polygon")        (ref:gpar)
    col = superpose.polygon$col
    border = superpose.polygon$border 
    lwd = superpose.polygon$lwd 
    
    ## Draw polygons
    for (i in seq_len(nVars)){                                    (ref:forVars)
        xi <- x[groups==groupLevels[i]]
        yi <- y[groups==groupLevels[i]]
        panel.polygon(xi, yi, border = border,
                      lwd = lwd, col = col[i])
    }
    
    ## Print labels
    for (i in seq_len(nVars)){
        xi <- x[groups==groupLevels[i]]
        yi <- y[groups==groupLevels[i]]
        N <- length(xi)/2
        ## Height available for the label
        h <- unit(yi[idxMaxes[i]], 'native') -
            unit(yi[idxMaxes[i] + 2*(N-idxMaxes[i]) +1], 'native')
        ##...converted to "char" units
        hChar <- convertHeight(h, 'char', TRUE)
        ## If there is enough space and we are not at the first or
        ## last variable, then the label is printed inside the polygon.
        if((hChar >= 1) && !(i %in% c(1, nVars))){                  (ref:hChar)
            grid.text(groupLevels[i],
                      xi[idxMaxes[i]],
                      (yi[idxMaxes[i]] +
                       yi[idxMaxes[i] + 2*(N-idxMaxes[i]) +1])/2,
                      gp = gpar(col = 'white', alpha = 0.7, cex = 0.7),
                      default.units = 'native')
        } else {
            ## Elsewhere, the label is printed outside
            
            grid.text(groupLevels[i],
                      xi[N],
                      (yi[N] + yi[N+1])/2,
                      gp = gpar(col = col[i], cex = 0.7),
                      just = 'left', default.units = 'native')
        }          
    }
}
  
#+end_src

#+NAME: prepanelFlow
#+begin_src R :exports none
prepanel.flow <- function(x, y, groups, origin,...)
{
    dat <- data.frame(x = x, y = y, groups = groups)
    nVars <- nlevels(groups)
    groupLevels <- levels(groups)
    yWide <- unstack(dat, y~groups)
    if (origin=='themeRiver') origin =  -1/2*rowSums(yWide)
    else origin = 0
    yWide <- cbind(origin = origin, yWide)
    yCumSum <- t(apply(yWide, 1, cumsum))
    
    list(xlim = range(x),                                            (ref:xlim)
         ylim = c(min(yCumSum[,1]), max(yCumSum[,nVars+1])),         (ref:ylim)
         dx = diff(x),                                                 (ref:dx)
         dy = diff(c(yCumSum[,-1])))
}
#+end_src

#+begin_src R :results output graphics :exports both :file "figs/unemployUSAThemeRiver.pdf" 
library(colorspace)
## We will use a qualitative palette from colorspace
nCols <- ncol(unemployUSA)
pal <- rainbow_hcl(nCols, c = 70, l = 75, start = 30, end = 300)
myTheme <- custom.theme(fill = pal, lwd = 0.2)

sep2008 <- as.numeric(as.yearmon('2008-09'))

xyplot(unemployUSA, superpose = TRUE, auto.key = FALSE,
       panel = panel.flow, prepanel = prepanel.flow,
       origin = 'themeRiver', scales = list(y = list(draw = FALSE)),
       par.settings = myTheme) +
    layer(panel.abline(v = sep2008, col = 'gray', lwd = 0.7))
#+end_src

#+CAPTION: ThemeRiver of unemployment in the United States. label:fig:unemployUSAThemeRiver
#+RESULTS:
[[file:figs/unemployUSAThemeRiver.pdf]]

This figure can help answer several questions. For example:
- What is the industry or class of worker with the lowest/highest
  unemployment figures during this time period?
- What is the industry or class of worker with the lowest/highest
  unemployment increases due to the financial crisis?
- There are a number of local maxima and minima of the total
  unemployment numbers. Are all the classes contributing to the
  maxima/minima?  Do all the classes exhibit the same fluctuation
  behavior as the global evolution?
More questions and answers can be found in the "Current Employment
Statistics" reports from the Bureau of Labor Statistics[fn:2].



** \floweroneleft Panel and Prepanel Functions to Implement the ThemeRiver with =xyplot= label:sec:themeRiverPanel
#+begin_src R :exports none
##################################################################
## Panel and prepanel functions to implement the ThemeRiver with =xyplot=
##################################################################
#+end_src

The =xyplot= function displays information according to the class
of its first argument (methods) and to the =panel= function. We
will use the =xyplot.zoo= method (equivalent to the =xyplot.ts=
method) with a new custom =panel= function.  This new panel
function has four main arguments, three of them calculated by
=xyplot= (=x=, =y= and =groups=) and a new one, =origin=. Of
course, it includes the =...= argument to provide additional
arguments.

The first step is to create a =data.frame= with coordinates and with
the =groups= factor (line [[(dataframe)]]). The value and number of the
levels will be used in the main step of this =panel= function. With
this =data.frame= we have to calculate the =y= and =x= coordinates for
each group to get a stacked set of polygons.

This =data.frame= is in the /long/ format, with a row for each
observation, and where the =group= column identifies the
variable. Thus, it must be transformed to the /wide/ format, with a
column for each variable. With the =unstack= function, a new
=data.frame= is produced whose columns are defined according to the
formula =y ~ groups= and with a row for each time position (line
[[(yunstack)]]). The stack of polygons is the result of the cumulative sum
of each row (line [[(ycumsum)]]). The origin of this sum is defined with
the corresponding =origin= argument: with =themeRiver=, the polygons
are arranged in a symmetric way.

Each column of this matrix of cumulative sums defines the =y=
coordinate of each variable (where =origin= is now the first
variable). The polygon of each variable is between this curve
(=iCol+1=) and the one of the previous variable (=iCol=) (line
[[(yPolygon)]]). In order to get a closed polygon, the coordinates of the
inferior limit are in reverse order. This new =data.frame= (=Y=) is in
the /wide/ format, but =xyplot= requires the information in the /long/
format: the =y= coordinates of the polygons are extracted from the
=values= column of the /long/ version of this =data.frame= (line
[[(yStack)]]).

The =x= coordinates are produced in an easier way. Again, =unstack=
produces a =data.frame= with a column for each variable and a row for
each time position (line [[(xunstack)]]), but now, because the =x=
coordinates are the same for the set of polygons, the corresponding
vector is constructed directly using a combination of concatenation
and repetition (line [[(xPolygon)]]).

Finally, the =groups= vector is produced, repeating each element of
the columns of the original =data.frame= (=dat$groups=) twice to
account for the forward and reverse curves of the corresponding
polygon (line [[(groups)]]).

The final step before displaying the polygons is to acquire the
graphical settings. The information retrieved with
=trellis.par.get= is transferred to the corresponding arguments of
=panel.polygon= (line [[(gpar)]]).

Everything is ready for constructing the polygons. With a =for= loop
(line [[(forVars)]]), the coordinates of the corresponding group are
extracted from the =x= and =y= vectors, and a polygon is displayed
with =panel.polygon=. The labels of each polygon (the =levels= of the
original =groups= variable, =groupLevels=) are printed inside the
polygon if there is enough room for the text (=hChar>1=) or at the
right if the polygon is too small, or if it is the first or last
variable of the set (line [[(hChar)]]). Both the polygons and the labels
share the same color (=col[i]=).

#+INDEX: Subjects!Panel function

#+begin_src R -n -r :noweb yes :tangle no
<<panelFlow>>
#+end_src

With this panel function, =xyplot= displays a set of stacked
polygons corresponding to the multivariate time series (Figure
ref:fig:themeRiverError). However, the graphical window is not
large enough, and part of the polygons fall out of it. Why?

#+begin_src R :results output graphics :tangle no :exports both :file "figs/ThemeRiverError.pdf" 
xyplot(unemployUSA, superpose = TRUE, auto.key = FALSE,
       panel = panel.flow, origin = 'themeRiver',
       par.settings = myTheme, cex = 0.4, offset = 0,
       scales = list(y = list(draw = FALSE)))
#+end_src

#+CAPTION: First attempt of ThemeRiver. label:fig:themeRiverError
#+ATTR_LaTeX: :height 0.45\textheight
#+RESULTS:
[[file:figs/ThemeRiverError.pdf]]

The problem is that =lattice= makes a preliminary estimate of the
window size using a default =prepanel= function that is unaware of the
internal calculations of our new =panel.flow= function. The solution
is to define a new =prepanel.flow= function. 

The input arguments and first lines are the same as in
=panel.flow=. The output is a list whose elements are the limits for
each axis (=xlim= and =ylim=, line [[(xlim)]]), and the sequence of
differences (=dx= and =dy=, line [[(dx)]]) that can be used for the aspect
and banking calculations.

The limits of the x-axis are defined with the range of the time index,
while the limits of the y-axis are calculated with the minimum of the
first column of =yCumSum= (the origin line) and with the maximum of
its last column (the upper line of the cumulative sum) (line [[(ylim)]]).

#+begin_src R -n -r :noweb yes :tangle no
<<prepanelFlow>>
#+end_src


* Interactive Graphics label:sec:interactive_horizontal

#+INDEX: Subjects!Interactive visualization

This section describes the interactive alternatives of the static
figures included in the previous sections with several packages:
=dygraphs=, =highcharter=, =plotly=, and =streamgraph=. These packages
are =R= interfaces to JavaScript libraries based on the =htmlwidgets=
package.

** Dygraphs label:sec:dygraphs
The =dygraphs= package is an interface to the =dygraphs= JavaScript
library, and provides facilities for charting time-series. It works
automatically with =xts= time series objects, or with objects than can
be coerced to this class. The result is an interactive graph, where
values are displayed according to the mouse position over the time
series. Regions can be selected to zoom into a time period. Figure
ref:fig:dygraphs is an snapshot of the interactive graph.

#+INDEX: Packages!dygraphs@\texttt{dygraphs}

#+begin_src R
library(dygraphs)

dyTemp <- dygraph(aranjuez[, c("TempMin", "TempAvg", "TempMax")],
                  main = "Temperature in Aranjuez",
                  ylab = "ºC")

dyTemp
#+end_src

#+CAPTION: Snapshot of an interactive graphic produced with \texttt{dygraphs}. label:fig:dygraphs
[[file:figs/dygraphs_aranjuez.png]]

You can customize =dygraphs= by piping additional commands onto the
original graphic.  The function =dyOptions= provides several choices
for the graphic, and the function =dyHighlight= configures options for
data series mouse-over highlighting. For example, with the next code
the semi-transparency value of the non-selected lines is reduced and
the width of selected line is increased (Figure
ref:fig:dygraphs_selected).

#+begin_src R
dyTemp %>%
    dyHighlight(highlightSeriesBackgroundAlpha = 0.2,
                highlightSeriesOpts = list(strokeWidth = 2))
#+end_src

#+CAPTION: Snapshot of a selection in an interactive graphic produced with \texttt{dygraphs}. label:fig:dygraphs_selected
[[file:figs/dygraphs_aranjuez_selected.png]]

An alternative approach to depict the upper and lower variables of
this time series is with a shaded region. The =dySeries= function
accepts a character vector of length 3 that specifies a set of input
column names to use as the lower, value, and upper for a series with a
shaded region around it (Figure ref:fig:dygraphs_maxmin).
#+begin_src R
dygraph(aranjuez[, c("TempMin", "TempAvg", "TempMax")],
        main = "Temperature in Aranjuez",
        ylab = "ºC") %>%
    dySeries(c("TempMin", "TempAvg", "TempMax"),
             label = "Temperature")
#+end_src

#+CAPTION: Shaded region between upper and lower values around a time series. label:fig:dygraphs_maxmin
[[file:figs/dygraphs_aranjuez_maxmin.png]]

** Highcharter label:sec:highcharter

The =highcharter= package is an interface to the =highcharts=
JavaScript library, with a wide spectrum of graphics
solutions. Displaying time series with this package can be achieved
with the combination of the generic =highchart= function and several
calls to the =hc_add_series_xts= function through the pipe =%>%=
operator.  Once again, the result is an interactive graph with
selection and zoom capabilities. Figure ref:fig:highcharter is an
snapshot of the interactive graph, and Figure
ref:fig:highcharter_zoom is an snapshot of this same graph with
zoom.

#+INDEX: Packages!highcharter@\texttt{highcharter}
#+INDEX: Packages!xts@\texttt{xts}

#+begin_src R
library(highcharter)
library(xts)

aranjuezXTS <- as.xts(aranjuez)

highchart() %>%
    hc_add_series(name = 'TempMax',
                      aranjuezXTS[, "TempMax"]) %>%
    hc_add_series(name = 'TempMin',
                      aranjuezXTS[, "TempMin"]) %>%
    hc_add_series(name = 'TempAvg',
                      aranjuezXTS[, "TempAvg"])
#+end_src

#+CAPTION: Snapshot of an interactive graphic produced with \texttt{highcharter}. label:fig:highcharter
[[file:figs/highcharter_aranjuez.png]]

#+CAPTION: Snapshot of a zoom in an interactive graphic produced with \texttt{highcharter}. label:fig:highcharter_zoom
[[file:figs/highcharter_aranjuez_zoom.png]]

** plotly label:sec:plotly_horizontal

The =plotly= package is an interface to the =plotly= JavaScript
library, also with a wide spectrum of graphics solutions. This package
does not provide any function specifically focused on time
series. Thus, the time series object has to be transformed in a
=data.frame= including a column for the time index. If the
=data.frame= is in /wide/ format (one column per variable), each
variable will be represented with a call to the =add_lines=
function. However, if the =data.frame= is in /long/ format (a column
for values, and a column for variable names) only one call to
=add_lines= is required. The next code follows this approach using the
combination of =fortify=, to convert the =zoo= object into a
=data.frame=, and =melt=, to transform from wide to long format.

#+begin_src R :results output :exports both
aranjuezDF <- fortify(aranjuez[,
                               c("TempMax",
                                 "TempAvg",
                                 "TempMin")],
                      melt = TRUE)

summary(aranjuezDF)
#+end_src

#+RESULTS:
:      Index                Series         Value        
:  Min.   :2004-01-01   TempMax:2898   Min.   :-12.980  
:  1st Qu.:2005-12-29   TempAvg:2898   1st Qu.:  7.107  
:  Median :2008-01-09   TempMin:2898   Median : 13.560  
:  Mean   :2008-01-03                  Mean   : 14.617  
:  3rd Qu.:2010-01-03                  3rd Qu.: 21.670  
:  Max.   :2011-12-31                  Max.   : 41.910  
:                                      NA's   :10


Figure ref:fig:plotly is a snapshot of the interactive graphic produce
with the generic function =plot_ly= connected with =add_lines= through
the pipe operator, =%>%=.

#+INDEX: Packages!plotly@\texttt{plotly}

#+begin_src R
library(plotly)

plot_ly(aranjuezDF) %>%
    add_lines(x = ~ Index,
              y = ~ Value,
              color = ~ Series)

#+end_src

#+CAPTION: Snapshot of an interactive graphic produced with \texttt{plotly}. label:fig:plotly
[[file:figs/plotly_aranjuez.png]]

#+CAPTION: Snapshot of a zoom in an interactive graphic produced with \texttt{plotly}. label:fig:plotly_zoom
[[file:figs/plotly_aranjuez_zoom.png]]


** streamgraph label:sec:interactive_streamgraph

The =streamgraph= package[fn:1] creates interactive stream graphs based on
the =htmlwidgets= package and the =D3.js= JavaScript library. Its main
function, =streamgraph=, requires a =data.frame= as the first
argument. Besides, its three next arguments, =key=, =value=, and
=date=, make this function a good candidate to work together with
=fortify= and =melt=.

#+begin_src R :results output :exports both
unemployDF <- fortify(unemployUSA, melt = TRUE)

head(unemployDF)
#+end_src

#+RESULTS:
:      Index Series Value
: 1 ene 2000  32230    19
: 2 feb 2000  32230    25
: 3 mar 2000  32230    17
: 4 abr 2000  32230    20
: 5 may 2000  32230    27
: 6 jun 2000  32230    13

Figures ref:fig:streamgraph_interactive and
ref:fig:streamgraph_interactive_selected are snapshots of the
interactive graphic created with the functions =streamgraph=,
=sg_axis=, and =sg_fill_brewer=, connected through the pipe operator,
=%>%=.

#+INDEX: Packages!streamgraph@\texttt{streamgraph}
#+INDEX: Subjects!Stacked graph

#+begin_src R
## remotes::install_github("hrbrmstr/streamgraph")
library(streamgraph)
#+end_src

#+begin_src R
streamgraph(unemployDF,
            key = "Series",
            value = "Value",
            date = "Index") %>%
    sg_axis_x(1, "year", "%Y") %>%
    sg_fill_brewer("Set1")
#+end_src

#+CAPTION: Streamgraph created with the =streamgraph= package, without selection. label:fig:streamgraph_interactive
[[file:figs/streamgraph_interactive.png]]

#+CAPTION: Streamgraph created with the =streamgraph= package, with a selection. label:fig:streamgraph_interactive_selected
[[file:figs/streamgraph_interactive_selected.png]]

* Footnotes

[fn:1] The =streamgraph= package, http://hrbrmstr.github.io/streamgraph/, is not available in CRAN. It can be installed using the =devtools= or the =remotes= package.

[fn:2] The March 2012 highlights report is available at http://www.bls.gov/ces/highlights032012.pdf.

[fn:3] A similar result can be obtained with =autoplot= using =facets=NULL=. 

[fn:4] The code of these panel and prepanel functions is explained
  in Section ref:sec:themeRiverPanel.

[fn:5] This approach was inspired by the =strip= function of the
=metvurst= package
https://metvurst.wordpress.com/2013/03/04/visualising-large-amounts-of-hourly-environmental-data-2/

